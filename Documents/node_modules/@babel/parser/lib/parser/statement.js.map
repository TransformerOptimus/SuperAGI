{"version":3,"names":["_types","require","_expression","_parseError","_identifier","_whitespace","_scopeflags","_util","_productionParameter","_expressionScope","_tokenizer","_location","_node","_lval","loopLabel","kind","switchLabel","ParseFunctionFlag","Expression","Declaration","HangingDeclaration","NullableId","Async","exports","ParseStatementFlag","StatementOnly","AllowImportExport","AllowDeclaration","AllowFunctionDeclaration","AllowLabeledFunction","loneSurrogate","keywordRelationalOperator","babel7CompatTokens","tokens","input","i","length","token","type","loc","start","value","end","hashEndPos","hashEndLoc","createPositionWithColumnOffset","splice","Token","getExportedToken","startLoc","endLoc","tokenIsTemplate","backquoteEnd","backquoteEndLoc","startToken","charCodeAt","templateValue","templateElementEnd","templateElementEndLoc","endToken","slice","StatementParser","ExpressionParser","parseTopLevel","file","program","parseProgram","comments","state","options","finishNode","sourceType","interpreter","parseInterpreterDirective","parseBlockBody","inModule","allowUndeclaredExports","scope","undefinedExports","size","localName","at","Array","from","raise","Errors","ModuleExportUndefined","finishedProgram","finishNodeAt","stmtToDirective","stmt","directive","expression","directiveLiteral","expressionValue","raw","val","addExtra","match","node","startNode","next","isLet","isContextual","hasFollowingBindingAtom","chStartsBindingIdentifier","ch","pos","isIdentifierStart","lastIndex","test","endCh","codePointAtPos","isIdentifierChar","chStartsBindingPattern","nextTokenStart","nextCh","hasInLineFollowingBindingIdentifier","nextTokenInLineStart","startsUsingForOf","containsEsc","lookahead","tokenIsIdentifier","hasFollowingLineBreak","expectPlugin","parseModuleItem","parseStatementLike","parseStatementListItem","annexB","strict","parseStatementOrSloppyAnnexBFunctionDeclaration","allowLabeledFunction","flags","parseStatement","decorators","parseDecorators","parseStatementContent","starttype","allowDeclaration","allowFunctionDeclaration","topLevel","parseBreakContinueStatement","parseDebuggerStatement","parseDoWhileStatement","parseForStatement","lookaheadCharCode","StrictFunction","SloppyFunctionAnnexB","SloppyFunction","parseFunctionStatement","unexpected","parseClass","maybeTakeDecorators","parseIfStatement","parseReturnStatement","parseSwitchStatement","parseThrowStatement","parseTryStatement","inTopLevel","UnexpectedUsingDeclaration","UnexpectedLexicalDeclaration","parseVarStatement","parseWhileStatement","parseWithStatement","parseBlock","parseEmptyStatement","nextTokenCharCode","allowImportExportEverywhere","UnexpectedImportExport","result","parseImport","importKind","sawUnambiguousESM","parseExport","exportKind","assertModuleNodeAllowed","isAsyncFunction","AsyncFunctionInSingleStatementContext","maybeName","expr","parseExpression","eat","parseLabeledStatement","parseExpressionStatement","ImportOutsideModule","decoratorsEnabledBeforeExport","hasPlugin","getPluginOption","maybeDecorators","classNode","exportNode","DecoratorsBeforeAfterExport","unshift","resetStartLocationFromNode","canHaveLeadingDecorator","allowExport","push","parseDecorator","DecoratorExportClass","UnexpectedLeadingDecorator","expectOnePlugin","expect","wrapParenthesis","paramsStartLoc","parseMaybeDecoratorArguments","DecoratorArgumentsOutsideParentheses","parseIdentifier","startNodeAt","object","classScope","usePrivateName","property","parsePrivateName","computed","parseExprSubscripts","startNodeAtNode","callee","arguments","parseCallExpressionArguments","toReferencedList","isBreak","isLineTerminator","label","semicolon","verifyBreakContinue","labels","lab","name","IllegalBreakContinue","parseHeaderExpression","body","withSmartMixTopicForbiddingContext","pop","awaitAt","isAwaitAllowed","eatContextual","lastTokStartLoc","enter","SCOPE_OTHER","parseFor","startsWithLet","startsWithUsing","isLetOrUsing","initNode","parseVar","init","isForIn","ForInUsing","declarations","parseForIn","startsWithAsync","refExpressionErrors","ExpressionErrors","isForOf","ForOfLet","ForOfAsync","checkDestructuringPrivate","toAssignable","checkLVal","in","checkExpressionErrors","isAsync","isHangingDeclaration","parseFunction","consequent","alternate","prodParam","hasReturn","allowReturnOutsideFunction","IllegalReturn","argument","discriminant","cases","cur","sawDefault","isCase","MultipleDefaultsInSwitch","exit","hasPrecedingLineBreak","NewlineAfterThrow","lastTokEndLoc","parseCatchClauseParam","param","parseBindingAtom","SCOPE_SIMPLE_CATCH","binding","BIND_CATCH_PARAM","block","handler","clause","finalizer","NoCatchOrFinally","allowMissingInitializer","StrictWith","LabelRedeclaration","labelName","tokenIsLoop","statementStart","allowDirectives","createNewLexicalScope","afterBlockParse","strictErrors","clear","isValidDirective","extra","parenthesized","directives","parseBlockOrModuleBlockBody","undefined","oldStrict","hasStrictModeDirective","parsedNonDirective","setStrict","call","update","await","id","ForInOfLoopInitializer","InvalidLhs","ancestor","left","right","parseMaybeAssignAllowIn","isFor","decl","parseVarId","parseMaybeAssignDisallowIn","DeclarationMissingInitializer","BIND_VAR","BIND_LEXICAL","parseAsyncFunctionExpression","hangingDeclaration","isDeclaration","requireId","initFunction","GeneratorInSingleStatementContext","generator","parseFunctionId","oldMaybeInArrowParameters","maybeInArrowParameters","SCOPE_FUNCTION","functionFlags","parseFunctionParams","parseFunctionBodyAndFinish","registerFunctionStatementId","isConstructor","expressionScope","newParameterDeclarationScope","params","parseBindingList","ParseBindingListFlags","IS_FUNCTION_PARAMS","IS_CONSTRUCTOR_PARAMS","declareName","async","treatFunctionsAsVar","BIND_FUNCTION","isStatement","optionalId","parseClassId","parseClassSuper","parseClassBody","superClass","isClassProperty","isClassMethod","isNonstaticConstructor","method","static","key","hadSuperClass","hadConstructor","classBody","DecoratorSemicolon","member","parseClassMember","DecoratorConstructor","TrailingDecorator","parseClassMemberFromModifier","pushClassMethod","prop","parseClassProperty","resetPreviousNodeTrailingComments","isStatic","parseClassStaticBlock","parseClassMemberWithIsStatic","publicMethod","privateMethod","publicProp","privateProp","accessorProp","publicMember","parsePropertyNamePrefixOperator","isPrivateName","parseClassElementName","pushClassPrivateMethod","ConstructorIsGenerator","isPrivate","maybeQuestionTokenStartLoc","parsePostMemberNameModifiers","allowsDirectSuper","DuplicateConstructor","override","OverrideOnConstructor","pushClassPrivateProperty","pushClassProperty","isGenerator","optional","ConstructorIsAsync","ConstructorIsAccessor","checkGetterSetterParams","pushClassAccessorProperty","StaticPrototype","ConstructorClassPrivateField","parsePropertyName","_member$decorators","SCOPE_CLASS","SCOPE_STATIC_BLOCK","SCOPE_SUPER","oldLabels","PARAM","DecoratorStaticBlock","ConstructorClassField","parseClassPrivateProperty","declarePrivateName","getPrivateNameSV","CLASS_ELEMENT_OTHER","parseClassAccessorProperty","parseMethod","CLASS_ELEMENT_STATIC_GETTER","CLASS_ELEMENT_INSTANCE_GETTER","CLASS_ELEMENT_STATIC_SETTER","CLASS_ELEMENT_INSTANCE_SETTER","declareClassPrivateMethodInScope","methodOrProp","parseInitializer","newExpressionScope","bindingType","BIND_CLASS","declareNameFromIdentifier","MissingClassName","hasDefault","maybeParseExportDefaultSpecifier","parseAfterDefault","hasStar","eatExportStar","hasNamespace","maybeParseExportNamespaceSpecifier","parseAfterNamespace","isFromRequired","UnsupportedDecoratorExport","parseExportFrom","hasSpecifiers","maybeParseExportNamedSpecifiers","hasDeclaration","maybeParseExportDeclaration","_node2$declaration","node2","checkExport","source","declaration","parseExportDefaultExpression","isExportDefaultSpecifier","specifier","exported","specifiers","parseModuleExportName","isTypeExport","parseExportSpecifiers","assertions","shouldParseExportDeclaration","parseExportDeclaration","lineBreak","isUnparsedContextual","DecoratorBeforeExport","UnsupportedDefaultExport","res","nextType","hasFrom","nextAfterFrom","nextTokenStartSince","parseImportSource","maybeParseImportAssertions","checkJSONModuleImport","checkNames","isDefault","isFrom","checkDuplicateExports","_declaration$extra","ExportDefaultFromAsIdentifier","exportName","local","ExportBindingIsString","checkReservedWord","checkLocalExport","Error","checkDeclaration","properties","elem","elements","exportedIdentifiers","has","DuplicateDefaultExport","DuplicateExport","add","isInTypeExport","nodes","first","isMaybeTypeOnly","isString","parseExportSpecifier","cloneStringLiteral","cloneIdentifier","parseStringLiteral","surrogate","ModuleExportNameHasLoneSurrogate","surrogateCharCode","isJSONModuleImport","some","checkImportReflection","module","_node$assertions","ImportReflectionNotBinding","ImportReflectionHasAssertion","nonDefaultNamedSpecifier","find","imported","ImportJSONBindingNotDefault","parseMaybeImportReflection","isImportReflection","nextNextTokenFirstChar","maybeParseDefaultImportSpecifier","parseNext","maybeParseStarImportSpecifier","parseNamedImportSpecifiers","expectContextual","attributes","maybeParseModuleAttributes","parseExprAtom","shouldParseDefaultImport","parseImportSpecifierLocal","finishImportSpecifier","parseAssertEntries","attrs","attrNames","Set","keyName","ModuleAttributesWithDuplicateKeys","ModuleAttributeInvalidValue","ModuleAttributeDifferentFromType","DestructureNamedImport","importedIsString","importSpecifier","parseImportSpecifier","isInTypeOnlyImport","ImportBindingIsString","importName","isThisParam","default"],"sources":["../../src/parser/statement.ts"],"sourcesContent":["import type * as N from \"../types\";\nimport {\n  tokenIsIdentifier,\n  tokenIsLoop,\n  tokenIsTemplate,\n  tt,\n  type TokenType,\n  getExportedToken,\n} from \"../tokenizer/types\";\nimport ExpressionParser from \"./expression\";\nimport { Errors } from \"../parse-error\";\nimport { isIdentifierChar, isIdentifierStart } from \"../util/identifier\";\nimport { lineBreak } from \"../util/whitespace\";\nimport * as charCodes from \"charcodes\";\nimport {\n  BIND_CLASS,\n  BIND_LEXICAL,\n  BIND_VAR,\n  BIND_FUNCTION,\n  SCOPE_CLASS,\n  SCOPE_FUNCTION,\n  SCOPE_OTHER,\n  SCOPE_SIMPLE_CATCH,\n  SCOPE_STATIC_BLOCK,\n  SCOPE_SUPER,\n  CLASS_ELEMENT_OTHER,\n  CLASS_ELEMENT_INSTANCE_GETTER,\n  CLASS_ELEMENT_INSTANCE_SETTER,\n  CLASS_ELEMENT_STATIC_GETTER,\n  CLASS_ELEMENT_STATIC_SETTER,\n  type BindingTypes,\n  BIND_CATCH_PARAM,\n} from \"../util/scopeflags\";\nimport { ExpressionErrors } from \"./util\";\nimport { PARAM, functionFlags } from \"../util/production-parameter\";\nimport {\n  newExpressionScope,\n  newParameterDeclarationScope,\n} from \"../util/expression-scope\";\nimport type { SourceType } from \"../options\";\nimport { Token } from \"../tokenizer\";\nimport type { Position } from \"../util/location\";\nimport { createPositionWithColumnOffset } from \"../util/location\";\nimport { cloneStringLiteral, cloneIdentifier, type Undone } from \"./node\";\nimport type Parser from \"./index\";\nimport { ParseBindingListFlags } from \"./lval\";\n\nconst loopLabel = { kind: \"loop\" } as const,\n  switchLabel = { kind: \"switch\" } as const;\n\nexport const enum ParseFunctionFlag {\n  Expression = 0b0000,\n  Declaration = 0b0001,\n  HangingDeclaration = 0b0010,\n  NullableId = 0b0100,\n  Async = 0b1000,\n}\n\nexport const enum ParseStatementFlag {\n  StatementOnly = 0b0000,\n  AllowImportExport = 0b0001,\n  AllowDeclaration = 0b0010,\n  AllowFunctionDeclaration = 0b0100,\n  AllowLabeledFunction = 0b1000,\n}\n\nconst loneSurrogate = /[\\uD800-\\uDFFF]/u;\n\nconst keywordRelationalOperator = /in(?:stanceof)?/y;\n\n/**\n * Convert tokens for backward Babel 7 compat.\n * tt.privateName => tt.hash + tt.name\n * tt.templateTail => tt.backquote/tt.braceR + tt.template + tt.backquote\n * tt.templateNonTail => tt.backquote/tt.braceR + tt.template + tt.dollarBraceL\n * For performance reasons this routine mutates `tokens`, it is okay\n * here since we execute `parseTopLevel` once for every file.\n */\nfunction babel7CompatTokens(tokens: (Token | N.Comment)[], input: string) {\n  for (let i = 0; i < tokens.length; i++) {\n    const token = tokens[i];\n    const { type } = token;\n    if (typeof type === \"number\") {\n      if (!process.env.BABEL_8_BREAKING) {\n        if (type === tt.privateName) {\n          const { loc, start, value, end } = token;\n          const hashEndPos = start + 1;\n          const hashEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          tokens.splice(\n            i,\n            1,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.hash),\n              value: \"#\",\n              start: start,\n              end: hashEndPos,\n              startLoc: loc.start,\n              endLoc: hashEndLoc,\n            }),\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.name),\n              value: value,\n              start: hashEndPos,\n              end: end,\n              startLoc: hashEndLoc,\n              endLoc: loc.end,\n            }),\n          );\n          i++;\n          continue;\n        }\n\n        if (tokenIsTemplate(type)) {\n          const { loc, start, value, end } = token;\n          const backquoteEnd = start + 1;\n          const backquoteEndLoc = createPositionWithColumnOffset(loc.start, 1);\n          let startToken;\n          if (input.charCodeAt(start) === charCodes.graveAccent) {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          } else {\n            startToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.braceR),\n              value: \"}\",\n              start: start,\n              end: backquoteEnd,\n              startLoc: loc.start,\n              endLoc: backquoteEndLoc,\n            });\n          }\n          let templateValue,\n            templateElementEnd,\n            templateElementEndLoc,\n            endToken;\n          if (type === tt.templateTail) {\n            // ends with '`'\n            templateElementEnd = end - 1;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -1);\n            templateValue = value === null ? null : value.slice(1, -1);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.backQuote),\n              value: \"`\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          } else {\n            // ends with `${`\n            templateElementEnd = end - 2;\n            templateElementEndLoc = createPositionWithColumnOffset(loc.end, -2);\n            templateValue = value === null ? null : value.slice(1, -2);\n            endToken = new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.dollarBraceL),\n              value: \"${\",\n              start: templateElementEnd,\n              end: end,\n              startLoc: templateElementEndLoc,\n              endLoc: loc.end,\n            });\n          }\n          tokens.splice(\n            i,\n            1,\n            startToken,\n            new Token({\n              // @ts-expect-error: hacky way to create token\n              type: getExportedToken(tt.template),\n              value: templateValue,\n              start: backquoteEnd,\n              end: templateElementEnd,\n              startLoc: backquoteEndLoc,\n              endLoc: templateElementEndLoc,\n            }),\n            endToken,\n          );\n          i += 2;\n          continue;\n        }\n      }\n      // @ts-expect-error: we manipulate `token` for performance reasons\n      token.type = getExportedToken(type);\n    }\n  }\n  return tokens;\n}\nexport default abstract class StatementParser extends ExpressionParser {\n  // ### Statement parsing\n\n  // Parse a program. Initializes the parser, reads any number of\n  // statements, and wraps them in a Program node.  Optionally takes a\n  // `program` argument.  If present, the statements will be appended\n  // to its body instead of creating a new node.\n\n  parseTopLevel(this: Parser, file: N.File, program: N.Program): N.File {\n    file.program = this.parseProgram(program);\n    file.comments = this.state.comments;\n\n    if (this.options.tokens) {\n      file.tokens = babel7CompatTokens(this.tokens, this.input);\n    }\n\n    return this.finishNode(file, \"File\");\n  }\n\n  parseProgram(\n    this: Parser,\n    program: Undone<N.Program>,\n    end: TokenType = tt.eof,\n    sourceType: SourceType = this.options.sourceType,\n  ): N.Program {\n    program.sourceType = sourceType;\n    program.interpreter = this.parseInterpreterDirective();\n    this.parseBlockBody(program, true, true, end);\n    if (\n      this.inModule &&\n      !this.options.allowUndeclaredExports &&\n      this.scope.undefinedExports.size > 0\n    ) {\n      for (const [localName, at] of Array.from(this.scope.undefinedExports)) {\n        this.raise(Errors.ModuleExportUndefined, { at, localName });\n      }\n    }\n    let finishedProgram: N.Program;\n    if (end === tt.eof) {\n      // finish at eof for top level program\n      finishedProgram = this.finishNode(program, \"Program\");\n    } else {\n      // finish immediately before the end token\n      finishedProgram = this.finishNodeAt(\n        program,\n        \"Program\",\n        createPositionWithColumnOffset(this.state.startLoc, -1),\n      );\n    }\n    return finishedProgram;\n  }\n\n  /**\n   * cast a Statement to a Directive. This method mutates input statement.\n   */\n  stmtToDirective(stmt: N.Statement): N.Directive {\n    const directive = stmt as any;\n    directive.type = \"Directive\";\n    directive.value = directive.expression;\n    delete directive.expression;\n\n    const directiveLiteral = directive.value;\n    const expressionValue = directiveLiteral.value;\n    const raw = this.input.slice(directiveLiteral.start, directiveLiteral.end);\n    const val = (directiveLiteral.value = raw.slice(1, -1)); // remove quotes\n\n    this.addExtra(directiveLiteral, \"raw\", raw);\n    this.addExtra(directiveLiteral, \"rawValue\", val);\n    this.addExtra(directiveLiteral, \"expressionValue\", expressionValue);\n\n    directiveLiteral.type = \"DirectiveLiteral\";\n\n    return directive;\n  }\n\n  parseInterpreterDirective(): N.InterpreterDirective | null {\n    if (!this.match(tt.interpreterDirective)) {\n      return null;\n    }\n\n    const node = this.startNode<N.InterpreterDirective>();\n    node.value = this.state.value;\n    this.next();\n    return this.finishNode(node, \"InterpreterDirective\");\n  }\n\n  isLet(): boolean {\n    if (!this.isContextual(tt._let)) {\n      return false;\n    }\n    return this.hasFollowingBindingAtom();\n  }\n\n  chStartsBindingIdentifier(ch: number, pos: number) {\n    if (isIdentifierStart(ch)) {\n      keywordRelationalOperator.lastIndex = pos;\n      if (keywordRelationalOperator.test(this.input)) {\n        // We have seen `in` or `instanceof` so far, now check if the identifier\n        // ends here\n        const endCh = this.codePointAtPos(keywordRelationalOperator.lastIndex);\n        if (!isIdentifierChar(endCh) && endCh !== charCodes.backslash) {\n          return false;\n        }\n      }\n      return true;\n    } else if (ch === charCodes.backslash) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  chStartsBindingPattern(ch: number) {\n    return (\n      ch === charCodes.leftSquareBracket || ch === charCodes.leftCurlyBrace\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `let` and declaration is allowed, check if it\n   * starts a variable declaration so that it should be interpreted as a keyword.\n   */\n  hasFollowingBindingAtom(): boolean {\n    const next = this.nextTokenStart();\n    const nextCh = this.codePointAtPos(next);\n    return (\n      this.chStartsBindingPattern(nextCh) ||\n      this.chStartsBindingIdentifier(nextCh, next)\n    );\n  }\n\n  /**\n   * Assuming we have seen a contextual `using` and declaration is allowed, check if it\n   * starts a variable declaration in the same line so that it should be interpreted as\n   * a keyword.\n   */\n  hasInLineFollowingBindingIdentifier(): boolean {\n    const next = this.nextTokenInLineStart();\n    const nextCh = this.codePointAtPos(next);\n    return this.chStartsBindingIdentifier(nextCh, next);\n  }\n\n  startsUsingForOf(): boolean {\n    const { type, containsEsc } = this.lookahead();\n    if (type === tt._of && !containsEsc) {\n      // `using of` must start a for-lhs-of statement\n      return false;\n    } else if (tokenIsIdentifier(type) && !this.hasFollowingLineBreak()) {\n      this.expectPlugin(\"explicitResourceManagement\");\n      return true;\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleItem\n  parseModuleItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowImportExport |\n        ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        // This function is actually also used to parse StatementItems,\n        // which with Annex B enabled allows labeled functions.\n        ParseStatementFlag.AllowLabeledFunction,\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-StatementListItem\n  parseStatementListItem(this: Parser) {\n    return this.parseStatementLike(\n      ParseStatementFlag.AllowDeclaration |\n        ParseStatementFlag.AllowFunctionDeclaration |\n        (!this.options.annexB || this.state.strict\n          ? 0\n          : ParseStatementFlag.AllowLabeledFunction),\n    );\n  }\n\n  parseStatementOrSloppyAnnexBFunctionDeclaration(\n    this: Parser,\n    allowLabeledFunction: boolean = false,\n  ) {\n    let flags: ParseStatementFlag = ParseStatementFlag.StatementOnly;\n    if (this.options.annexB && !this.state.strict) {\n      flags |= ParseStatementFlag.AllowFunctionDeclaration;\n      if (allowLabeledFunction) {\n        flags |= ParseStatementFlag.AllowLabeledFunction;\n      }\n    }\n    return this.parseStatementLike(flags);\n  }\n\n  // Parse a single statement.\n  //\n  // If expecting a statement and finding a slash operator, parse a\n  // regular expression literal. This is to handle cases like\n  // `if (foo) /blah/.exec(foo)`, where looking at the previous token\n  // does not help.\n  // https://tc39.es/ecma262/#prod-Statement\n  parseStatement(this: Parser) {\n    return this.parseStatementLike(ParseStatementFlag.StatementOnly);\n  }\n\n  // ImportDeclaration and ExportDeclaration are also handled here so we can throw recoverable errors\n  // when they are not at the top level\n  parseStatementLike(\n    this: Parser,\n    flags: ParseStatementFlag,\n  ):\n    | N.Statement\n    | N.Declaration\n    | N.ImportDeclaration\n    | N.ExportDefaultDeclaration\n    | N.ExportNamedDeclaration\n    | N.ExportAllDeclaration {\n    let decorators: N.Decorator[] | null = null;\n\n    if (this.match(tt.at)) {\n      decorators = this.parseDecorators(true);\n    }\n    return this.parseStatementContent(flags, decorators);\n  }\n\n  parseStatementContent(\n    this: Parser,\n    flags: ParseStatementFlag,\n    decorators?: N.Decorator[] | null,\n  ): N.Statement {\n    const starttype = this.state.type;\n    const node = this.startNode();\n    const allowDeclaration = !!(flags & ParseStatementFlag.AllowDeclaration);\n    const allowFunctionDeclaration = !!(\n      flags & ParseStatementFlag.AllowFunctionDeclaration\n    );\n    const topLevel = flags & ParseStatementFlag.AllowImportExport;\n\n    // Most types of statements are recognized by the keyword they\n    // start with. Many are trivial to parse, some require a bit of\n    // complexity.\n\n    switch (starttype) {\n      case tt._break:\n        return this.parseBreakContinueStatement(node, /* isBreak */ true);\n      case tt._continue:\n        return this.parseBreakContinueStatement(node, /* isBreak */ false);\n      case tt._debugger:\n        return this.parseDebuggerStatement(node as Undone<N.DebuggerStatement>);\n      case tt._do:\n        return this.parseDoWhileStatement(node as Undone<N.DoWhileStatement>);\n      case tt._for:\n        return this.parseForStatement(node as Undone<N.ForStatement>);\n      case tt._function:\n        if (this.lookaheadCharCode() === charCodes.dot) break;\n        if (!allowFunctionDeclaration) {\n          this.raise(\n            this.state.strict\n              ? Errors.StrictFunction\n              : this.options.annexB\n              ? Errors.SloppyFunctionAnnexB\n              : Errors.SloppyFunction,\n            { at: this.state.startLoc },\n          );\n        }\n        return this.parseFunctionStatement(\n          node as Undone<N.FunctionDeclaration>,\n          false,\n          !allowDeclaration && allowFunctionDeclaration,\n        );\n      case tt._class:\n        if (!allowDeclaration) this.unexpected();\n        return this.parseClass(\n          this.maybeTakeDecorators(\n            decorators,\n            node as Undone<N.ClassDeclaration>,\n          ),\n          true,\n        );\n\n      case tt._if:\n        return this.parseIfStatement(node as Undone<N.IfStatement>);\n      case tt._return:\n        return this.parseReturnStatement(node as Undone<N.ReturnStatement>);\n      case tt._switch:\n        return this.parseSwitchStatement(node as Undone<N.SwitchStatement>);\n      case tt._throw:\n        return this.parseThrowStatement(node as Undone<N.ThrowStatement>);\n      case tt._try:\n        return this.parseTryStatement(node as Undone<N.TryStatement>);\n\n      case tt._using:\n        // using [no LineTerminator here] BindingList[+Using]\n        if (\n          this.state.containsEsc ||\n          !this.hasInLineFollowingBindingIdentifier()\n        ) {\n          break;\n        }\n        this.expectPlugin(\"explicitResourceManagement\");\n        if (!this.scope.inModule && this.scope.inTopLevel) {\n          this.raise(Errors.UnexpectedUsingDeclaration, {\n            at: this.state.startLoc,\n          });\n        } else if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          \"using\",\n        );\n      case tt._let: {\n        if (this.state.containsEsc) {\n          break;\n        }\n        // `let [` is an explicit negative lookahead for\n        // ExpressionStatement, so special-case it first.\n        const next = this.nextTokenStart();\n        const nextCh = this.codePointAtPos(next);\n        if (nextCh !== charCodes.leftSquareBracket) {\n          if (!allowDeclaration && this.hasFollowingLineBreak()) break;\n          if (\n            !this.chStartsBindingIdentifier(nextCh, next) &&\n            nextCh !== charCodes.leftCurlyBrace\n          ) {\n            break;\n          }\n        }\n      }\n      // fall through\n      case tt._const: {\n        if (!allowDeclaration) {\n          this.raise(Errors.UnexpectedLexicalDeclaration, {\n            at: this.state.startLoc,\n          });\n        }\n      }\n      // fall through\n      case tt._var: {\n        const kind = this.state.value;\n        return this.parseVarStatement(\n          node as Undone<N.VariableDeclaration>,\n          kind,\n        );\n      }\n      case tt._while:\n        return this.parseWhileStatement(node as Undone<N.WhileStatement>);\n      case tt._with:\n        return this.parseWithStatement(node as Undone<N.WithStatement>);\n      case tt.braceL:\n        return this.parseBlock();\n      case tt.semi:\n        return this.parseEmptyStatement(node as Undone<N.EmptyStatement>);\n      case tt._import: {\n        const nextTokenCharCode = this.lookaheadCharCode();\n        if (\n          nextTokenCharCode === charCodes.leftParenthesis || // import()\n          nextTokenCharCode === charCodes.dot // import.meta\n        ) {\n          break;\n        }\n      }\n      // fall through\n      case tt._export: {\n        if (!this.options.allowImportExportEverywhere && !topLevel) {\n          this.raise(Errors.UnexpectedImportExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.next(); // eat `import`/`export`\n\n        let result;\n        if (starttype === tt._import) {\n          result = this.parseImport(node as Undone<N.ImportDeclaration>);\n\n          if (\n            result.type === \"ImportDeclaration\" &&\n            (!result.importKind || result.importKind === \"value\")\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        } else {\n          result = this.parseExport(\n            node as Undone<\n              | N.ExportAllDeclaration\n              | N.ExportDefaultDeclaration\n              | N.ExportDefaultDeclaration\n            >,\n            decorators,\n          );\n\n          if (\n            (result.type === \"ExportNamedDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            (result.type === \"ExportAllDeclaration\" &&\n              (!result.exportKind || result.exportKind === \"value\")) ||\n            result.type === \"ExportDefaultDeclaration\"\n          ) {\n            this.sawUnambiguousESM = true;\n          }\n        }\n\n        this.assertModuleNodeAllowed(result);\n\n        return result;\n      }\n\n      default: {\n        if (this.isAsyncFunction()) {\n          if (!allowDeclaration) {\n            this.raise(Errors.AsyncFunctionInSingleStatementContext, {\n              at: this.state.startLoc,\n            });\n          }\n          this.next(); // eat 'async'\n          return this.parseFunctionStatement(\n            node as Undone<N.FunctionDeclaration>,\n            true,\n            !allowDeclaration && allowFunctionDeclaration,\n          );\n        }\n      }\n    }\n\n    // If the statement does not start with a statement keyword or a\n    // brace, it's an ExpressionStatement or LabeledStatement. We\n    // simply start parsing an expression, and afterwards, if the\n    // next token is a colon and the expression was a simple\n    // Identifier node, we switch to interpreting it as a label.\n    const maybeName = this.state.value;\n    const expr = this.parseExpression();\n\n    if (\n      tokenIsIdentifier(starttype) &&\n      expr.type === \"Identifier\" &&\n      this.eat(tt.colon)\n    ) {\n      return this.parseLabeledStatement(\n        node as Undone<N.LabeledStatement>,\n        maybeName,\n        // @ts-expect-error migrate to Babel types\n        expr,\n        flags,\n      );\n    } else {\n      return this.parseExpressionStatement(\n        node as Undone<N.ExpressionStatement>,\n        expr,\n        decorators,\n      );\n    }\n  }\n\n  assertModuleNodeAllowed(node: N.Node): void {\n    if (!this.options.allowImportExportEverywhere && !this.inModule) {\n      this.raise(Errors.ImportOutsideModule, { at: node });\n    }\n  }\n\n  decoratorsEnabledBeforeExport(): boolean {\n    if (this.hasPlugin(\"decorators-legacy\")) return true;\n    return (\n      this.hasPlugin(\"decorators\") &&\n      this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") !== false\n    );\n  }\n\n  // Attach the decorators to the given class.\n  // NOTE: This method changes the .start location of the class, and thus\n  // can affect comment attachment. Calling it before or after finalizing\n  // the class node (and thus finalizing its comments) changes how comments\n  // before the `class` keyword or before the final .start location of the\n  // class are attached.\n  maybeTakeDecorators<T extends Undone<N.Class>>(\n    maybeDecorators: N.Decorator[] | null,\n    classNode: T,\n    exportNode?: Undone<N.ExportDefaultDeclaration | N.ExportNamedDeclaration>,\n  ): T {\n    if (maybeDecorators) {\n      if (classNode.decorators && classNode.decorators.length > 0) {\n        // Note: decorators attachment is only attempred multiple times\n        // when the class is part of an export declaration.\n        if (\n          typeof this.getPluginOption(\n            \"decorators\",\n            \"decoratorsBeforeExport\",\n          ) !== \"boolean\"\n        ) {\n          // If `decoratorsBeforeExport` was set to `true` or `false`, we\n          // already threw an error about decorators not being in a valid\n          // position.\n          this.raise(Errors.DecoratorsBeforeAfterExport, {\n            at: classNode.decorators[0],\n          });\n        }\n        classNode.decorators.unshift(...maybeDecorators);\n      } else {\n        classNode.decorators = maybeDecorators;\n      }\n      this.resetStartLocationFromNode(classNode, maybeDecorators[0]);\n      if (exportNode) this.resetStartLocationFromNode(exportNode, classNode);\n    }\n    return classNode;\n  }\n\n  canHaveLeadingDecorator(): boolean {\n    return this.match(tt._class);\n  }\n\n  parseDecorators(this: Parser, allowExport?: boolean): N.Decorator[] {\n    const decorators = [];\n    do {\n      decorators.push(this.parseDecorator());\n    } while (this.match(tt.at));\n\n    if (this.match(tt._export)) {\n      if (!allowExport) {\n        this.unexpected();\n      }\n\n      if (!this.decoratorsEnabledBeforeExport()) {\n        this.raise(Errors.DecoratorExportClass, { at: this.state.startLoc });\n      }\n    } else if (!this.canHaveLeadingDecorator()) {\n      throw this.raise(Errors.UnexpectedLeadingDecorator, {\n        at: this.state.startLoc,\n      });\n    }\n\n    return decorators;\n  }\n\n  parseDecorator(this: Parser): N.Decorator {\n    this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n\n    const node = this.startNode<N.Decorator>();\n    this.next();\n\n    if (this.hasPlugin(\"decorators\")) {\n      const startLoc = this.state.startLoc;\n      let expr: N.Expression;\n\n      if (this.match(tt.parenL)) {\n        const startLoc = this.state.startLoc;\n        this.next(); // eat '('\n        expr = this.parseExpression();\n        this.expect(tt.parenR);\n        expr = this.wrapParenthesis(startLoc, expr);\n\n        const paramsStartLoc = this.state.startLoc;\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n        if (\n          this.getPluginOption(\"decorators\", \"allowCallParenthesized\") ===\n            false &&\n          node.expression !== expr\n        ) {\n          this.raise(Errors.DecoratorArgumentsOutsideParentheses, {\n            at: paramsStartLoc,\n          });\n        }\n      } else {\n        expr = this.parseIdentifier(false);\n\n        while (this.eat(tt.dot)) {\n          const node = this.startNodeAt(startLoc);\n          node.object = expr;\n          if (this.match(tt.privateName)) {\n            this.classScope.usePrivateName(\n              this.state.value,\n              this.state.startLoc,\n            );\n            node.property = this.parsePrivateName();\n          } else {\n            node.property = this.parseIdentifier(true);\n          }\n          node.computed = false;\n          expr = this.finishNode(node, \"MemberExpression\");\n        }\n\n        node.expression = this.parseMaybeDecoratorArguments(expr);\n      }\n    } else {\n      node.expression = this.parseExprSubscripts();\n    }\n    return this.finishNode(node, \"Decorator\");\n  }\n\n  parseMaybeDecoratorArguments(this: Parser, expr: N.Expression): N.Expression {\n    if (this.eat(tt.parenL)) {\n      const node = this.startNodeAtNode(expr);\n      node.callee = expr;\n      node.arguments = this.parseCallExpressionArguments(tt.parenR, false);\n      this.toReferencedList(node.arguments);\n      return this.finishNode(node, \"CallExpression\");\n    }\n\n    return expr;\n  }\n\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: true,\n  ): N.BreakStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.Node>,\n    isBreak: false,\n  ): N.ContinueStatement;\n  parseBreakContinueStatement(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ): N.BreakStatement | N.ContinueStatement {\n    this.next();\n\n    if (this.isLineTerminator()) {\n      node.label = null;\n    } else {\n      node.label = this.parseIdentifier();\n      this.semicolon();\n    }\n\n    this.verifyBreakContinue(node, isBreak);\n\n    return this.finishNode(\n      node,\n      isBreak ? \"BreakStatement\" : \"ContinueStatement\",\n    );\n  }\n\n  verifyBreakContinue(\n    node: Undone<N.BreakStatement | N.ContinueStatement>,\n    isBreak: boolean,\n  ) {\n    let i;\n    for (i = 0; i < this.state.labels.length; ++i) {\n      const lab = this.state.labels[i];\n      if (node.label == null || lab.name === node.label.name) {\n        if (lab.kind != null && (isBreak || lab.kind === \"loop\")) break;\n        if (node.label && isBreak) break;\n      }\n    }\n    if (i === this.state.labels.length) {\n      const type = isBreak ? \"BreakStatement\" : \"ContinueStatement\";\n      this.raise(Errors.IllegalBreakContinue, { at: node, type });\n    }\n  }\n\n  parseDebuggerStatement(\n    node: Undone<N.DebuggerStatement>,\n  ): N.DebuggerStatement {\n    this.next();\n    this.semicolon();\n    return this.finishNode(node, \"DebuggerStatement\");\n  }\n\n  parseHeaderExpression(this: Parser): N.Expression {\n    this.expect(tt.parenL);\n    const val = this.parseExpression();\n    this.expect(tt.parenR);\n    return val;\n  }\n\n  // https://tc39.es/ecma262/#prod-DoWhileStatement\n  parseDoWhileStatement(\n    this: Parser,\n    node: Undone<N.DoWhileStatement>,\n  ): N.DoWhileStatement {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body's body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body's body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    this.expect(tt._while);\n    node.test = this.parseHeaderExpression();\n    this.eat(tt.semi);\n    return this.finishNode(node, \"DoWhileStatement\");\n  }\n\n  // Disambiguating between a `for` and a `for`/`in` or `for`/`of`\n  // loop is non-trivial. Basically, we have to parse the init `var`\n  // statement or expression, disallowing the `in` operator (see\n  // the second parameter to `parseExpression`), and then check\n  // whether the next token is `in` or `of`. When there is no init\n  // part (semicolon immediately after the opening parenthesis), it\n  // is a regular `for` loop.\n\n  parseForStatement(\n    this: Parser,\n    node: Undone<N.ForStatement | N.ForInOf>,\n  ): N.ForLike {\n    this.next();\n    this.state.labels.push(loopLabel);\n\n    let awaitAt = null;\n\n    if (this.isAwaitAllowed() && this.eatContextual(tt._await)) {\n      awaitAt = this.state.lastTokStartLoc;\n    }\n    this.scope.enter(SCOPE_OTHER);\n    this.expect(tt.parenL);\n\n    if (this.match(tt.semi)) {\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, null);\n    }\n\n    const startsWithLet = this.isContextual(tt._let);\n    const startsWithUsing = this.isContextual(tt._using);\n    const isLetOrUsing =\n      (startsWithLet && this.hasFollowingBindingAtom()) ||\n      (startsWithUsing && this.startsUsingForOf());\n    if (this.match(tt._var) || this.match(tt._const) || isLetOrUsing) {\n      const initNode = this.startNode<N.VariableDeclaration>();\n      const kind = this.state.value;\n      this.next();\n      this.parseVar(initNode, true, kind);\n      const init = this.finishNode(initNode, \"VariableDeclaration\");\n\n      const isForIn = this.match(tt._in);\n      if (isForIn && startsWithUsing) {\n        this.raise(Errors.ForInUsing, { at: init });\n      }\n      if (\n        (isForIn || this.isContextual(tt._of)) &&\n        init.declarations.length === 1\n      ) {\n        return this.parseForIn(node as Undone<N.ForInOf>, init, awaitAt);\n      }\n      if (awaitAt !== null) {\n        this.unexpected(awaitAt);\n      }\n      return this.parseFor(node as Undone<N.ForStatement>, init);\n    }\n\n    // Check whether the first token is possibly a contextual keyword, so that\n    // we can forbid `for (async of` if this turns out to be a for-of loop.\n    const startsWithAsync = this.isContextual(tt._async);\n\n    const refExpressionErrors = new ExpressionErrors();\n    const init = this.parseExpression(true, refExpressionErrors);\n    const isForOf = this.isContextual(tt._of);\n    if (isForOf) {\n      // Check for leading tokens that are forbidden in for-of loops:\n      if (startsWithLet) {\n        this.raise(Errors.ForOfLet, { at: init });\n      }\n\n      if (\n        // `for await (async of []);` is allowed.\n        awaitAt === null &&\n        startsWithAsync &&\n        init.type === \"Identifier\"\n      ) {\n        // This catches the case where the `async` in `for (async of` was\n        // parsed as an identifier. If it was parsed as the start of an async\n        // arrow function (e.g. `for (async of => {} of []);`), the LVal check\n        // further down will raise a more appropriate error.\n        this.raise(Errors.ForOfAsync, { at: init });\n      }\n    }\n    if (isForOf || this.match(tt._in)) {\n      this.checkDestructuringPrivate(refExpressionErrors);\n      this.toAssignable(init, /* isLHS */ true);\n      const type = isForOf ? \"ForOfStatement\" : \"ForInStatement\";\n      this.checkLVal(init, { in: { type } });\n      return this.parseForIn(\n        node as Undone<N.ForInStatement | N.ForOfStatement>,\n        // @ts-expect-error init has been transformed to an assignable\n        init,\n        awaitAt,\n      );\n    } else {\n      this.checkExpressionErrors(refExpressionErrors, true);\n    }\n    if (awaitAt !== null) {\n      this.unexpected(awaitAt);\n    }\n    return this.parseFor(node as Undone<N.ForStatement>, init);\n  }\n\n  // https://tc39.es/ecma262/#prod-HoistableDeclaration\n  parseFunctionStatement(\n    this: Parser,\n    node: Undone<N.FunctionDeclaration>,\n    isAsync: boolean,\n    isHangingDeclaration: boolean,\n  ): N.FunctionDeclaration {\n    this.next(); // eat 'function'\n    return this.parseFunction(\n      node,\n      ParseFunctionFlag.Declaration |\n        (isHangingDeclaration ? ParseFunctionFlag.HangingDeclaration : 0) |\n        (isAsync ? ParseFunctionFlag.Async : 0),\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-IfStatement\n  parseIfStatement(this: Parser, node: Undone<N.IfStatement>) {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    // Annex B.3.3\n    // https://tc39.es/ecma262/#sec-functiondeclarations-in-ifstatement-statement-clauses\n    node.consequent = this.parseStatementOrSloppyAnnexBFunctionDeclaration();\n    node.alternate = this.eat(tt._else)\n      ? this.parseStatementOrSloppyAnnexBFunctionDeclaration()\n      : null;\n    return this.finishNode(node, \"IfStatement\");\n  }\n\n  parseReturnStatement(this: Parser, node: Undone<N.ReturnStatement>) {\n    if (!this.prodParam.hasReturn && !this.options.allowReturnOutsideFunction) {\n      this.raise(Errors.IllegalReturn, { at: this.state.startLoc });\n    }\n\n    this.next();\n\n    // In `return` (and `break`/`continue`), the keywords with\n    // optional arguments, we eagerly look for a semicolon or the\n    // possibility to insert one.\n\n    if (this.isLineTerminator()) {\n      node.argument = null;\n    } else {\n      node.argument = this.parseExpression();\n      this.semicolon();\n    }\n\n    return this.finishNode(node, \"ReturnStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-SwitchStatement\n  parseSwitchStatement(this: Parser, node: Undone<N.SwitchStatement>) {\n    this.next();\n    node.discriminant = this.parseHeaderExpression();\n    const cases: N.SwitchStatement[\"cases\"] = (node.cases = []);\n    this.expect(tt.braceL);\n    this.state.labels.push(switchLabel);\n    this.scope.enter(SCOPE_OTHER);\n\n    // Statements under must be grouped (by label) in SwitchCase\n    // nodes. `cur` is used to keep the node that we are currently\n    // adding statements to.\n\n    let cur;\n    for (let sawDefault; !this.match(tt.braceR); ) {\n      if (this.match(tt._case) || this.match(tt._default)) {\n        const isCase = this.match(tt._case);\n        if (cur) this.finishNode(cur, \"SwitchCase\");\n        // @ts-expect-error Fixme\n        cases.push((cur = this.startNode()));\n        cur.consequent = [];\n        this.next();\n        if (isCase) {\n          cur.test = this.parseExpression();\n        } else {\n          if (sawDefault) {\n            this.raise(Errors.MultipleDefaultsInSwitch, {\n              at: this.state.lastTokStartLoc,\n            });\n          }\n          sawDefault = true;\n          cur.test = null;\n        }\n        this.expect(tt.colon);\n      } else {\n        if (cur) {\n          cur.consequent.push(this.parseStatementListItem());\n        } else {\n          this.unexpected();\n        }\n      }\n    }\n    this.scope.exit();\n    if (cur) this.finishNode(cur, \"SwitchCase\");\n    this.next(); // Closing brace\n    this.state.labels.pop();\n    return this.finishNode(node, \"SwitchStatement\");\n  }\n\n  parseThrowStatement(this: Parser, node: Undone<N.ThrowStatement>) {\n    this.next();\n    if (this.hasPrecedingLineBreak()) {\n      this.raise(Errors.NewlineAfterThrow, { at: this.state.lastTokEndLoc });\n    }\n    node.argument = this.parseExpression();\n    this.semicolon();\n    return this.finishNode(node, \"ThrowStatement\");\n  }\n\n  parseCatchClauseParam(this: Parser): N.Pattern {\n    const param = this.parseBindingAtom();\n\n    this.scope.enter(\n      this.options.annexB && param.type === \"Identifier\"\n        ? SCOPE_SIMPLE_CATCH\n        : 0,\n    );\n    this.checkLVal(param, {\n      in: { type: \"CatchClause\" },\n      binding: BIND_CATCH_PARAM,\n    });\n\n    return param;\n  }\n\n  parseTryStatement(\n    this: Parser,\n    node: Undone<N.TryStatement>,\n  ): N.TryStatement {\n    this.next();\n\n    node.block = this.parseBlock();\n    node.handler = null;\n\n    if (this.match(tt._catch)) {\n      const clause = this.startNode<N.CatchClause>();\n      this.next();\n      if (this.match(tt.parenL)) {\n        this.expect(tt.parenL);\n        clause.param = this.parseCatchClauseParam();\n        this.expect(tt.parenR);\n      } else {\n        clause.param = null;\n        this.scope.enter(SCOPE_OTHER);\n      }\n\n      // Parse the catch clause's body.\n      clause.body =\n        // For the smartPipelines plugin: Disable topic references from outer\n        // contexts within the catch clause's body.\n        this.withSmartMixTopicForbiddingContext(() =>\n          // Parse the catch clause's body.\n          this.parseBlock(false, false),\n        );\n\n      this.scope.exit();\n      node.handler = this.finishNode(clause, \"CatchClause\");\n    }\n\n    node.finalizer = this.eat(tt._finally) ? this.parseBlock() : null;\n\n    if (!node.handler && !node.finalizer) {\n      this.raise(Errors.NoCatchOrFinally, { at: node });\n    }\n\n    return this.finishNode(node, \"TryStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-VariableStatement\n  // https://tc39.es/ecma262/#prod-LexicalDeclaration\n  parseVarStatement(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\",\n    allowMissingInitializer: boolean = false,\n  ): N.VariableDeclaration {\n    this.next();\n    this.parseVar(node, false, kind, allowMissingInitializer);\n    this.semicolon();\n    return this.finishNode(node, \"VariableDeclaration\");\n  }\n\n  // https://tc39.es/ecma262/#prod-WhileStatement\n  parseWhileStatement(\n    this: Parser,\n    node: Undone<N.WhileStatement>,\n  ): N.WhileStatement {\n    this.next();\n    node.test = this.parseHeaderExpression();\n    this.state.labels.push(loopLabel);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"WhileStatement\");\n  }\n\n  parseWithStatement(\n    this: Parser,\n    node: Undone<N.WithStatement>,\n  ): N.WithStatement {\n    if (this.state.strict) {\n      this.raise(Errors.StrictWith, { at: this.state.startLoc });\n    }\n    this.next();\n    node.object = this.parseHeaderExpression();\n\n    // Parse the statement body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the with statement's body.\n      // They are permitted in function default-parameter expressions, which are\n      // part of the outer context, outside of the with statement's body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the statement body.\n        this.parseStatement(),\n      );\n\n    return this.finishNode(node, \"WithStatement\");\n  }\n\n  parseEmptyStatement(node: Undone<N.EmptyStatement>): N.EmptyStatement {\n    this.next();\n    return this.finishNode(node, \"EmptyStatement\");\n  }\n\n  // https://tc39.es/ecma262/#prod-LabelledStatement\n  parseLabeledStatement(\n    this: Parser,\n    node: Undone<N.LabeledStatement>,\n    maybeName: string,\n    expr: N.Identifier,\n    flags: ParseStatementFlag,\n  ): N.LabeledStatement {\n    for (const label of this.state.labels) {\n      if (label.name === maybeName) {\n        this.raise(Errors.LabelRedeclaration, {\n          at: expr,\n          labelName: maybeName,\n        });\n      }\n    }\n\n    const kind = tokenIsLoop(this.state.type)\n      ? \"loop\"\n      : this.match(tt._switch)\n      ? \"switch\"\n      : null;\n    for (let i = this.state.labels.length - 1; i >= 0; i--) {\n      const label = this.state.labels[i];\n      if (label.statementStart === node.start) {\n        label.statementStart = this.state.start;\n        label.kind = kind;\n      } else {\n        break;\n      }\n    }\n\n    this.state.labels.push({\n      name: maybeName,\n      kind: kind,\n      statementStart: this.state.start,\n    });\n    // https://tc39.es/ecma262/#prod-LabelledItem\n    node.body =\n      flags & ParseStatementFlag.AllowLabeledFunction\n        ? this.parseStatementOrSloppyAnnexBFunctionDeclaration(true)\n        : this.parseStatement();\n\n    this.state.labels.pop();\n    node.label = expr;\n    return this.finishNode(node, \"LabeledStatement\");\n  }\n\n  parseExpressionStatement(\n    node: Undone<N.ExpressionStatement>,\n    expr: N.Expression,\n    /* eslint-disable-next-line @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    decorators: N.Decorator[] | null,\n  ) {\n    node.expression = expr;\n    this.semicolon();\n    return this.finishNode(node, \"ExpressionStatement\");\n  }\n\n  // Parse a semicolon-enclosed block of statements, handling `\"use\n  // strict\"` declarations when `allowDirectives` is true (used for\n  // function bodies).\n\n  parseBlock(\n    this: Parser,\n    allowDirectives: boolean = false,\n    createNewLexicalScope: boolean = true,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): N.BlockStatement {\n    const node = this.startNode<N.BlockStatement>();\n    if (allowDirectives) {\n      this.state.strictErrors.clear();\n    }\n    this.expect(tt.braceL);\n    if (createNewLexicalScope) {\n      this.scope.enter(SCOPE_OTHER);\n    }\n    this.parseBlockBody(\n      node,\n      allowDirectives,\n      false,\n      tt.braceR,\n      afterBlockParse,\n    );\n    if (createNewLexicalScope) {\n      this.scope.exit();\n    }\n    return this.finishNode(node, \"BlockStatement\");\n  }\n\n  isValidDirective(stmt: N.Statement): boolean {\n    return (\n      stmt.type === \"ExpressionStatement\" &&\n      stmt.expression.type === \"StringLiteral\" &&\n      !stmt.expression.extra.parenthesized\n    );\n  }\n\n  parseBlockBody(\n    this: Parser,\n    node: Undone<N.BlockStatementLike>,\n    allowDirectives: boolean | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const body: N.BlockStatementLike[\"body\"] = (node.body = []);\n    const directives: N.BlockStatementLike[\"directives\"] = (node.directives =\n      []);\n    this.parseBlockOrModuleBlockBody(\n      body,\n      allowDirectives ? directives : undefined,\n      topLevel,\n      end,\n      afterBlockParse,\n    );\n  }\n\n  // Undefined directives means that directives are not allowed.\n  // https://tc39.es/ecma262/#prod-Block\n  // https://tc39.es/ecma262/#prod-ModuleBody\n  parseBlockOrModuleBlockBody(\n    this: Parser,\n    body: N.Statement[],\n    directives: N.Directive[] | undefined | null,\n    topLevel: boolean,\n    end: TokenType,\n    afterBlockParse?: (hasStrictModeDirective: boolean) => void,\n  ): void {\n    const oldStrict = this.state.strict;\n    let hasStrictModeDirective = false;\n    let parsedNonDirective = false;\n\n    while (!this.match(end)) {\n      const stmt = topLevel\n        ? this.parseModuleItem()\n        : this.parseStatementListItem();\n\n      if (directives && !parsedNonDirective) {\n        if (this.isValidDirective(stmt)) {\n          const directive = this.stmtToDirective(stmt);\n          directives.push(directive);\n\n          if (\n            !hasStrictModeDirective &&\n            directive.value.value === \"use strict\"\n          ) {\n            hasStrictModeDirective = true;\n            this.setStrict(true);\n          }\n\n          continue;\n        }\n        parsedNonDirective = true;\n        // clear strict errors since the strict mode will not change within the block\n        this.state.strictErrors.clear();\n      }\n      body.push(stmt);\n    }\n\n    if (afterBlockParse) {\n      afterBlockParse.call(this, hasStrictModeDirective);\n    }\n\n    if (!oldStrict) {\n      this.setStrict(false);\n    }\n\n    this.next();\n  }\n\n  // Parse a regular `for` loop. The disambiguation code in\n  // `parseStatement` will already have parsed the init statement or\n  // expression.\n\n  parseFor(\n    this: Parser,\n    node: Undone<N.ForStatement>,\n    init?: N.VariableDeclaration | N.Expression | null,\n  ): N.ForStatement {\n    node.init = init;\n    this.semicolon(/* allowAsi */ false);\n    node.test = this.match(tt.semi) ? null : this.parseExpression();\n    this.semicolon(/* allowAsi */ false);\n    node.update = this.match(tt.parenR) ? null : this.parseExpression();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin: Disable topic references from outer\n      // contexts within the loop body. They are permitted in test expressions,\n      // outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse the loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, \"ForStatement\");\n  }\n\n  // Parse a `for`/`in` and `for`/`of` loop, which are almost\n  // same from parser's perspective.\n\n  parseForIn(\n    this: Parser,\n    node: Undone<N.ForInOf>,\n    init: N.VariableDeclaration | N.AssignmentPattern,\n    awaitAt?: Position | null,\n  ): N.ForInOf {\n    const isForIn = this.match(tt._in);\n    this.next();\n\n    if (isForIn) {\n      if (awaitAt !== null) this.unexpected(awaitAt);\n    } else {\n      node.await = awaitAt !== null;\n    }\n\n    if (\n      init.type === \"VariableDeclaration\" &&\n      init.declarations[0].init != null &&\n      (!isForIn ||\n        !this.options.annexB ||\n        this.state.strict ||\n        init.kind !== \"var\" ||\n        init.declarations[0].id.type !== \"Identifier\")\n    ) {\n      this.raise(Errors.ForInOfLoopInitializer, {\n        at: init,\n        type: isForIn ? \"ForInStatement\" : \"ForOfStatement\",\n      });\n    }\n\n    if (init.type === \"AssignmentPattern\") {\n      this.raise(Errors.InvalidLhs, {\n        at: init,\n        ancestor: { type: \"ForStatement\" },\n      });\n    }\n\n    node.left = init;\n    node.right = isForIn\n      ? this.parseExpression()\n      : this.parseMaybeAssignAllowIn();\n    this.expect(tt.parenR);\n\n    // Parse the loop body.\n    node.body =\n      // For the smartPipelines plugin:\n      // Disable topic references from outer contexts within the loop body.\n      // They are permitted in test expressions, outside of the loop body.\n      this.withSmartMixTopicForbiddingContext(() =>\n        // Parse loop body.\n        this.parseStatement(),\n      );\n\n    this.scope.exit();\n    this.state.labels.pop();\n\n    return this.finishNode(node, isForIn ? \"ForInStatement\" : \"ForOfStatement\");\n  }\n\n  // Parse a list of variable declarations.\n\n  parseVar(\n    this: Parser,\n    node: Undone<N.VariableDeclaration>,\n    isFor: boolean,\n    kind: \"var\" | \"let\" | \"const\" | \"using\",\n    allowMissingInitializer: boolean = false,\n  ): Undone<N.VariableDeclaration> {\n    const declarations: N.VariableDeclarator[] = (node.declarations = []);\n    node.kind = kind;\n    for (;;) {\n      const decl = this.startNode<N.VariableDeclarator>();\n      this.parseVarId(decl, kind);\n      decl.init = !this.eat(tt.eq)\n        ? null\n        : isFor\n        ? this.parseMaybeAssignDisallowIn()\n        : this.parseMaybeAssignAllowIn();\n\n      if (decl.init === null && !allowMissingInitializer) {\n        if (\n          decl.id.type !== \"Identifier\" &&\n          !(isFor && (this.match(tt._in) || this.isContextual(tt._of)))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"destructuring\",\n          });\n        } else if (\n          kind === \"const\" &&\n          !(this.match(tt._in) || this.isContextual(tt._of))\n        ) {\n          this.raise(Errors.DeclarationMissingInitializer, {\n            at: this.state.lastTokEndLoc,\n            kind: \"const\",\n          });\n        }\n      }\n      declarations.push(this.finishNode(decl, \"VariableDeclarator\"));\n      if (!this.eat(tt.comma)) break;\n    }\n    return node;\n  }\n\n  parseVarId(\n    this: Parser,\n    decl: Undone<N.VariableDeclarator>,\n    kind: \"var\" | \"let\" | \"const\" | \"using\",\n  ): void {\n    const id = this.parseBindingAtom();\n    this.checkLVal(id, {\n      in: { type: \"VariableDeclarator\" },\n      binding: kind === \"var\" ? BIND_VAR : BIND_LEXICAL,\n    });\n    decl.id = id;\n  }\n\n  // https://tc39.es/ecma262/#prod-AsyncFunctionExpression\n  parseAsyncFunctionExpression(\n    this: Parser,\n    node: Undone<N.FunctionExpression>,\n  ): N.FunctionExpression {\n    return this.parseFunction(node, ParseFunctionFlag.Async);\n  }\n\n  // Parse a function declaration or expression (depending on the\n  // ParseFunctionFlag.Declaration flag).\n\n  parseFunction<T extends N.NormalFunction>(\n    this: Parser,\n    node: Undone<T>,\n    flags: ParseFunctionFlag = ParseFunctionFlag.Expression,\n  ): T {\n    const hangingDeclaration = flags & ParseFunctionFlag.HangingDeclaration;\n    const isDeclaration = !!(flags & ParseFunctionFlag.Declaration);\n    const requireId = isDeclaration && !(flags & ParseFunctionFlag.NullableId);\n    const isAsync = !!(flags & ParseFunctionFlag.Async);\n\n    this.initFunction(node, isAsync);\n\n    if (this.match(tt.star)) {\n      if (hangingDeclaration) {\n        this.raise(Errors.GeneratorInSingleStatementContext, {\n          at: this.state.startLoc,\n        });\n      }\n      this.next(); // eat *\n      node.generator = true;\n    }\n\n    if (isDeclaration) {\n      node.id = this.parseFunctionId(requireId);\n    }\n\n    const oldMaybeInArrowParameters = this.state.maybeInArrowParameters;\n    this.state.maybeInArrowParameters = false;\n    this.scope.enter(SCOPE_FUNCTION);\n    this.prodParam.enter(functionFlags(isAsync, node.generator));\n\n    if (!isDeclaration) {\n      node.id = this.parseFunctionId();\n    }\n\n    this.parseFunctionParams(node, /* isConstructor */ false);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the function body. They are permitted in function\n    // default-parameter expressions, outside of the function body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the function body.\n      this.parseFunctionBodyAndFinish(\n        node,\n        isDeclaration ? \"FunctionDeclaration\" : \"FunctionExpression\",\n      );\n    });\n\n    this.prodParam.exit();\n    this.scope.exit();\n\n    if (isDeclaration && !hangingDeclaration) {\n      // We need to register this _after_ parsing the function body\n      // because of TypeScript body-less function declarations,\n      // which shouldn't be added to the scope.\n      this.registerFunctionStatementId(node as T);\n    }\n\n    this.state.maybeInArrowParameters = oldMaybeInArrowParameters;\n    return node as T;\n  }\n\n  parseFunctionId(requireId?: boolean): N.Identifier | undefined | null {\n    return requireId || tokenIsIdentifier(this.state.type)\n      ? this.parseIdentifier()\n      : null;\n  }\n\n  parseFunctionParams(\n    this: Parser,\n    node: Undone<N.Function>,\n    isConstructor?: boolean,\n  ): void {\n    this.expect(tt.parenL);\n    this.expressionScope.enter(newParameterDeclarationScope());\n    node.params = this.parseBindingList(\n      tt.parenR,\n      charCodes.rightParenthesis,\n      ParseBindingListFlags.IS_FUNCTION_PARAMS |\n        (isConstructor ? ParseBindingListFlags.IS_CONSTRUCTOR_PARAMS : 0),\n    );\n\n    this.expressionScope.exit();\n  }\n\n  registerFunctionStatementId(node: N.Function): void {\n    if (!node.id) return;\n\n    // If it is a regular function declaration in sloppy mode, then it is\n    // subject to Annex B semantics (BIND_FUNCTION). Otherwise, the binding\n    // mode depends on properties of the current scope (see\n    // treatFunctionsAsVar).\n    this.scope.declareName(\n      node.id.name,\n      !this.options.annexB || this.state.strict || node.generator || node.async\n        ? this.scope.treatFunctionsAsVar\n          ? BIND_VAR\n          : BIND_LEXICAL\n        : BIND_FUNCTION,\n      node.id.loc.start,\n    );\n  }\n\n  // Parse a class declaration or literal (depending on the\n  // `isStatement` parameter).\n\n  parseClass<T extends N.Class>(\n    this: Parser,\n    node: Undone<T>,\n    isStatement: /* T === ClassDeclaration */ boolean,\n    optionalId?: boolean,\n  ): T {\n    this.next(); // 'class'\n\n    // A class definition is always strict mode code.\n    const oldStrict = this.state.strict;\n    this.state.strict = true;\n\n    this.parseClassId(node, isStatement, optionalId);\n    this.parseClassSuper(node);\n    // this.state.strict is restored in parseClassBody\n    node.body = this.parseClassBody(!!node.superClass, oldStrict);\n\n    return this.finishNode(\n      node,\n      isStatement ? \"ClassDeclaration\" : \"ClassExpression\",\n    );\n  }\n\n  isClassProperty(): boolean {\n    return this.match(tt.eq) || this.match(tt.semi) || this.match(tt.braceR);\n  }\n\n  isClassMethod(): boolean {\n    return this.match(tt.parenL);\n  }\n\n  isNonstaticConstructor(method: N.ClassMethod | N.ClassProperty): boolean {\n    return (\n      !method.computed &&\n      !method.static &&\n      (method.key.name === \"constructor\" || // Identifier\n        method.key.value === \"constructor\") // String literal\n    );\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassBody\n  parseClassBody(\n    this: Parser,\n    hadSuperClass: boolean,\n    oldStrict: boolean,\n  ): N.ClassBody {\n    this.classScope.enter();\n\n    const state: N.ParseClassMemberState = {\n      hadConstructor: false,\n      hadSuperClass,\n    };\n    let decorators: N.Decorator[] = [];\n    const classBody = this.startNode<N.ClassBody>();\n    classBody.body = [];\n\n    this.expect(tt.braceL);\n\n    // For the smartPipelines plugin: Disable topic references from outer\n    // contexts within the class body.\n    this.withSmartMixTopicForbiddingContext(() => {\n      // Parse the contents within the braces.\n      while (!this.match(tt.braceR)) {\n        if (this.eat(tt.semi)) {\n          if (decorators.length > 0) {\n            throw this.raise(Errors.DecoratorSemicolon, {\n              at: this.state.lastTokEndLoc,\n            });\n          }\n          continue;\n        }\n\n        if (this.match(tt.at)) {\n          decorators.push(this.parseDecorator());\n          continue;\n        }\n\n        const member = this.startNode<N.ClassMember>();\n\n        // steal the decorators if there are any\n        if (decorators.length) {\n          // @ts-expect-error Fixme\n          member.decorators = decorators;\n          this.resetStartLocationFromNode(member, decorators[0]);\n          decorators = [];\n        }\n\n        this.parseClassMember(classBody, member, state);\n\n        if (\n          // @ts-expect-error Fixme\n          member.kind === \"constructor\" &&\n          // @ts-expect-error Fixme\n          member.decorators &&\n          // @ts-expect-error Fixme\n          member.decorators.length > 0\n        ) {\n          this.raise(Errors.DecoratorConstructor, { at: member });\n        }\n      }\n    });\n\n    this.state.strict = oldStrict;\n\n    this.next(); // eat `}`\n\n    if (decorators.length) {\n      throw this.raise(Errors.TrailingDecorator, { at: this.state.startLoc });\n    }\n\n    this.classScope.exit();\n\n    return this.finishNode(classBody, \"ClassBody\");\n  }\n\n  // returns true if the current identifier is a method/field name,\n  // false if it is a modifier\n  parseClassMemberFromModifier(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n  ): boolean {\n    const key = this.parseIdentifier(true); // eats the modifier\n\n    if (this.isClassMethod()) {\n      const method: N.ClassMethod = member as any;\n\n      // a method named like the modifier\n      method.kind = \"method\";\n      method.computed = false;\n      method.key = key;\n      method.static = false;\n      this.pushClassMethod(\n        classBody,\n        method,\n        false,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n      return true;\n    } else if (this.isClassProperty()) {\n      const prop: N.ClassProperty = member as any;\n\n      // a property named like the modifier\n      prop.computed = false;\n      prop.key = key;\n      prop.static = false;\n      classBody.body.push(this.parseClassProperty(prop));\n      return true;\n    }\n    this.resetPreviousNodeTrailingComments(key);\n    return false;\n  }\n\n  parseClassMember(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n  ): void {\n    const isStatic = this.isContextual(tt._static);\n\n    if (isStatic) {\n      if (this.parseClassMemberFromModifier(classBody, member)) {\n        // a class element named 'static'\n        return;\n      }\n      if (this.eat(tt.braceL)) {\n        this.parseClassStaticBlock(classBody, member as any as N.StaticBlock);\n        return;\n      }\n    }\n\n    this.parseClassMemberWithIsStatic(classBody, member, state, isStatic);\n  }\n\n  parseClassMemberWithIsStatic(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<N.ClassMember>,\n    state: N.ParseClassMemberState,\n    isStatic: boolean,\n  ) {\n    const publicMethod = member as N.ClassMethod;\n    const privateMethod = member as N.ClassPrivateMethod;\n    const publicProp = member as N.ClassProperty;\n    const privateProp = member as N.ClassPrivateProperty;\n    const accessorProp = member as N.ClassAccessorProperty;\n\n    const method: typeof publicMethod | typeof privateMethod = publicMethod;\n    const publicMember: typeof publicMethod | typeof publicProp = publicMethod;\n\n    member.static = isStatic;\n    this.parsePropertyNamePrefixOperator(member);\n\n    if (this.eat(tt.star)) {\n      // a generator\n      method.kind = \"method\";\n      const isPrivateName = this.match(tt.privateName);\n      this.parseClassElementName(method);\n\n      if (isPrivateName) {\n        // Private generator method\n        this.pushClassPrivateMethod(classBody, privateMethod, true, false);\n        return;\n      }\n\n      if (this.isNonstaticConstructor(publicMethod)) {\n        this.raise(Errors.ConstructorIsGenerator, {\n          at: publicMethod.key,\n        });\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        true,\n        false,\n        /* isConstructor */ false,\n        false,\n      );\n\n      return;\n    }\n\n    const isContextual =\n      tokenIsIdentifier(this.state.type) && !this.state.containsEsc;\n    const isPrivate = this.match(tt.privateName);\n    const key = this.parseClassElementName(member);\n    const maybeQuestionTokenStartLoc = this.state.startLoc;\n\n    this.parsePostMemberNameModifiers(publicMember);\n\n    if (this.isClassMethod()) {\n      method.kind = \"method\";\n\n      if (isPrivate) {\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n        return;\n      }\n\n      // a normal method\n      const isConstructor = this.isNonstaticConstructor(publicMethod);\n      let allowsDirectSuper = false;\n      if (isConstructor) {\n        publicMethod.kind = \"constructor\";\n\n        // TypeScript allows multiple overloaded constructor declarations.\n        if (state.hadConstructor && !this.hasPlugin(\"typescript\")) {\n          this.raise(Errors.DuplicateConstructor, { at: key });\n        }\n        if (isConstructor && this.hasPlugin(\"typescript\") && member.override) {\n          this.raise(Errors.OverrideOnConstructor, { at: key });\n        }\n        state.hadConstructor = true;\n        allowsDirectSuper = state.hadSuperClass;\n      }\n\n      this.pushClassMethod(\n        classBody,\n        publicMethod,\n        false,\n        false,\n        isConstructor,\n        allowsDirectSuper,\n      );\n    } else if (this.isClassProperty()) {\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else if (\n      isContextual &&\n      key.name === \"async\" &&\n      !this.isLineTerminator()\n    ) {\n      // an async method\n      this.resetPreviousNodeTrailingComments(key);\n      const isGenerator = this.eat(tt.star);\n\n      if (publicMember.optional) {\n        this.unexpected(maybeQuestionTokenStartLoc);\n      }\n\n      method.kind = \"method\";\n      // The so-called parsed name would have been \"async\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(method);\n      this.parsePostMemberNameModifiers(publicMember);\n\n      if (isPrivate) {\n        // private async method\n        this.pushClassPrivateMethod(\n          classBody,\n          privateMethod,\n          isGenerator,\n          true,\n        );\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAsync, { at: publicMethod.key });\n        }\n\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          isGenerator,\n          true,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n    } else if (\n      isContextual &&\n      (key.name === \"get\" || key.name === \"set\") &&\n      !(this.match(tt.star) && this.isLineTerminator())\n    ) {\n      // `get\\n*` is an uninitialized property named 'get' followed by a generator.\n      // a getter or setter\n      this.resetPreviousNodeTrailingComments(key);\n      method.kind = key.name;\n      // The so-called parsed name would have been \"get/set\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicMethod);\n\n      if (isPrivate) {\n        // private getter/setter\n        this.pushClassPrivateMethod(classBody, privateMethod, false, false);\n      } else {\n        if (this.isNonstaticConstructor(publicMethod)) {\n          this.raise(Errors.ConstructorIsAccessor, { at: publicMethod.key });\n        }\n        this.pushClassMethod(\n          classBody,\n          publicMethod,\n          false,\n          false,\n          /* isConstructor */ false,\n          false,\n        );\n      }\n\n      this.checkGetterSetterParams(publicMethod);\n    } else if (\n      isContextual &&\n      key.name === \"accessor\" &&\n      !this.isLineTerminator()\n    ) {\n      this.expectPlugin(\"decoratorAutoAccessors\");\n      this.resetPreviousNodeTrailingComments(key);\n\n      // The so-called parsed name would have been \"accessor\": get the real name.\n      const isPrivate = this.match(tt.privateName);\n      this.parseClassElementName(publicProp);\n      this.pushClassAccessorProperty(classBody, accessorProp, isPrivate);\n    } else if (this.isLineTerminator()) {\n      // an uninitialized class property (due to ASI, since we don't otherwise recognize the next token)\n      if (isPrivate) {\n        this.pushClassPrivateProperty(classBody, privateProp);\n      } else {\n        this.pushClassProperty(classBody, publicProp);\n      }\n    } else {\n      this.unexpected();\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassElementName\n  parseClassElementName(\n    this: Parser,\n    member: Undone<N.ClassMember>,\n  ): N.Expression | N.Identifier {\n    const { type, value } = this.state;\n    if (\n      (type === tt.name || type === tt.string) &&\n      member.static &&\n      value === \"prototype\"\n    ) {\n      this.raise(Errors.StaticPrototype, { at: this.state.startLoc });\n    }\n\n    if (type === tt.privateName) {\n      if (value === \"constructor\") {\n        this.raise(Errors.ConstructorClassPrivateField, {\n          at: this.state.startLoc,\n        });\n      }\n      const key = this.parsePrivateName();\n      member.key = key;\n      return key;\n    }\n\n    return this.parsePropertyName(member);\n  }\n\n  parseClassStaticBlock(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    member: Undone<\n      N.StaticBlock & {\n        decorators?: Array<N.Decorator>;\n      }\n    >,\n  ) {\n    // Start a new lexical scope\n    this.scope.enter(SCOPE_CLASS | SCOPE_STATIC_BLOCK | SCOPE_SUPER);\n    // Start a new scope with regard to loop labels\n    const oldLabels = this.state.labels;\n    this.state.labels = [];\n    // ClassStaticBlockStatementList:\n    //   StatementList[~Yield, ~Await, ~Return] opt\n    this.prodParam.enter(PARAM);\n    const body: N.Node[] = (member.body = []);\n    this.parseBlockOrModuleBlockBody(body, undefined, false, tt.braceR);\n    this.prodParam.exit();\n    this.scope.exit();\n    this.state.labels = oldLabels;\n    classBody.body.push(this.finishNode<N.StaticBlock>(member, \"StaticBlock\"));\n    if (member.decorators?.length) {\n      this.raise(Errors.DecoratorStaticBlock, { at: member });\n    }\n  }\n\n  pushClassProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassProperty,\n  ) {\n    if (\n      !prop.computed &&\n      (prop.key.name === \"constructor\" || prop.key.value === \"constructor\")\n    ) {\n      // Non-computed field, which is either an identifier named \"constructor\"\n      // or a string literal named \"constructor\"\n      this.raise(Errors.ConstructorClassField, { at: prop.key });\n    }\n\n    classBody.body.push(this.parseClassProperty(prop));\n  }\n\n  pushClassPrivateProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: Undone<N.ClassPrivateProperty>,\n  ) {\n    const node = this.parseClassPrivateProperty(prop);\n    classBody.body.push(node);\n\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      CLASS_ELEMENT_OTHER,\n      node.key.loc.start,\n    );\n  }\n\n  pushClassAccessorProperty(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    prop: N.ClassAccessorProperty,\n    isPrivate: boolean,\n  ) {\n    if (!isPrivate && !prop.computed) {\n      // Not private, so not node is not a PrivateName and we can safely cast\n      const key = prop.key as N.Expression;\n\n      if (key.name === \"constructor\" || key.value === \"constructor\") {\n        // Non-computed field, which is either an identifier named \"constructor\"\n        // or a string literal named \"constructor\"\n        this.raise(Errors.ConstructorClassField, { at: key });\n      }\n    }\n\n    const node = this.parseClassAccessorProperty(prop);\n    classBody.body.push(node);\n\n    if (isPrivate) {\n      this.classScope.declarePrivateName(\n        this.getPrivateNameSV(node.key),\n        CLASS_ELEMENT_OTHER,\n        node.key.loc.start,\n      );\n    }\n  }\n\n  pushClassMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n    isConstructor: boolean,\n    allowsDirectSuper: boolean,\n  ): void {\n    classBody.body.push(\n      this.parseMethod(\n        method,\n        isGenerator,\n        isAsync,\n        isConstructor,\n        allowsDirectSuper,\n        \"ClassMethod\",\n        true,\n      ),\n    );\n  }\n\n  pushClassPrivateMethod(\n    this: Parser,\n    classBody: Undone<N.ClassBody>,\n    method: Undone<N.ClassPrivateMethod>,\n    isGenerator: boolean,\n    isAsync: boolean,\n  ): void {\n    const node = this.parseMethod(\n      method,\n      isGenerator,\n      isAsync,\n      /* isConstructor */ false,\n      false,\n      \"ClassPrivateMethod\",\n      true,\n    );\n    classBody.body.push(node);\n\n    const kind =\n      node.kind === \"get\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_GETTER\n          : CLASS_ELEMENT_INSTANCE_GETTER\n        : node.kind === \"set\"\n        ? node.static\n          ? CLASS_ELEMENT_STATIC_SETTER\n          : CLASS_ELEMENT_INSTANCE_SETTER\n        : CLASS_ELEMENT_OTHER;\n    this.declareClassPrivateMethodInScope(node, kind);\n  }\n\n  declareClassPrivateMethodInScope(\n    node: Undone<\n      N.ClassPrivateMethod | N.EstreeMethodDefinition | N.TSDeclareMethod\n    >,\n    kind: number,\n  ) {\n    this.classScope.declarePrivateName(\n      this.getPrivateNameSV(node.key),\n      kind,\n      node.key.loc.start,\n    );\n  }\n\n  // Overridden in typescript.js\n  parsePostMemberNameModifiers(\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    methodOrProp: Undone<N.ClassMethod | N.ClassProperty>,\n  ): void {}\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassPrivateProperty(\n    this: Parser,\n    node: Undone<N.ClassPrivateProperty>,\n  ): N.ClassPrivateProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassPrivateProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-FieldDefinition\n  parseClassProperty(this: Parser, node: N.ClassProperty): N.ClassProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassProperty\");\n  }\n\n  parseClassAccessorProperty(\n    this: Parser,\n    node: N.ClassAccessorProperty,\n  ): N.ClassAccessorProperty {\n    this.parseInitializer(node);\n    this.semicolon();\n    return this.finishNode(node, \"ClassAccessorProperty\");\n  }\n\n  // https://tc39.es/ecma262/#prod-Initializer\n  parseInitializer(\n    this: Parser,\n    node: Undone<\n      N.ClassProperty | N.ClassPrivateProperty | N.ClassAccessorProperty\n    >,\n  ): void {\n    this.scope.enter(SCOPE_CLASS | SCOPE_SUPER);\n    this.expressionScope.enter(newExpressionScope());\n    this.prodParam.enter(PARAM);\n    node.value = this.eat(tt.eq) ? this.parseMaybeAssignAllowIn() : null;\n    this.expressionScope.exit();\n    this.prodParam.exit();\n    this.scope.exit();\n  }\n\n  parseClassId(\n    node: Undone<N.Class>,\n    isStatement: boolean,\n    optionalId?: boolean | null,\n    bindingType: BindingTypes = BIND_CLASS,\n  ): void {\n    if (tokenIsIdentifier(this.state.type)) {\n      node.id = this.parseIdentifier();\n      if (isStatement) {\n        this.declareNameFromIdentifier(node.id, bindingType);\n      }\n    } else {\n      if (optionalId || !isStatement) {\n        node.id = null;\n      } else {\n        throw this.raise(Errors.MissingClassName, { at: this.state.startLoc });\n      }\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ClassHeritage\n  parseClassSuper(this: Parser, node: Undone<N.Class>): void {\n    node.superClass = this.eat(tt._extends) ? this.parseExprSubscripts() : null;\n  }\n\n  // Parses module export declaration.\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n\n  parseExport(\n    this: Parser,\n    node: Undone<\n      | N.ExportDefaultDeclaration\n      | N.ExportAllDeclaration\n      | N.ExportNamedDeclaration\n    >,\n    decorators: N.Decorator[] | null,\n  ): N.AnyExport {\n    const hasDefault = this.maybeParseExportDefaultSpecifier(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n    const parseAfterDefault = !hasDefault || this.eat(tt.comma);\n    const hasStar =\n      parseAfterDefault &&\n      this.eatExportStar(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const hasNamespace =\n      hasStar &&\n      this.maybeParseExportNamespaceSpecifier(\n        // @ts-expect-error todo(flow->ts)\n        node,\n      );\n    const parseAfterNamespace =\n      parseAfterDefault && (!hasNamespace || this.eat(tt.comma));\n    const isFromRequired = hasDefault || hasStar;\n\n    if (hasStar && !hasNamespace) {\n      if (hasDefault) this.unexpected();\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(node as Undone<N.ExportNamedDeclaration>, true);\n\n      return this.finishNode(node, \"ExportAllDeclaration\");\n    }\n\n    const hasSpecifiers = this.maybeParseExportNamedSpecifiers(\n      // @ts-expect-error todo(flow->ts)\n      node,\n    );\n\n    if (hasDefault && parseAfterDefault && !hasStar && !hasSpecifiers) {\n      this.unexpected(null, tt.braceL);\n    }\n\n    if (hasNamespace && parseAfterNamespace) {\n      this.unexpected(null, tt._from);\n    }\n\n    let hasDeclaration;\n    if (isFromRequired || hasSpecifiers) {\n      hasDeclaration = false;\n      if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      this.parseExportFrom(\n        node as Undone<N.ExportNamedDeclaration>,\n        isFromRequired,\n      );\n    } else {\n      hasDeclaration = this.maybeParseExportDeclaration(\n        node as Undone<N.ExportNamedDeclaration>,\n      );\n    }\n\n    if (isFromRequired || hasSpecifiers || hasDeclaration) {\n      const node2 = node as Undone<N.ExportNamedDeclaration>;\n      this.checkExport(node2, true, false, !!node2.source);\n      if (node2.declaration?.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, node2.declaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n      return this.finishNode(node2, \"ExportNamedDeclaration\");\n    }\n\n    if (this.eat(tt._default)) {\n      const node2 = node as Undone<N.ExportDefaultDeclaration>;\n      // export default ...\n      const decl = this.parseExportDefaultExpression();\n      node2.declaration = decl;\n\n      if (decl.type === \"ClassDeclaration\") {\n        this.maybeTakeDecorators(decorators, decl as N.ClassDeclaration, node2);\n      } else if (decorators) {\n        throw this.raise(Errors.UnsupportedDecoratorExport, { at: node });\n      }\n\n      this.checkExport(node2, true, true);\n\n      return this.finishNode(node2, \"ExportDefaultDeclaration\");\n    }\n\n    this.unexpected(null, tt.braceL);\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  eatExportStar(node: N.Node): boolean {\n    return this.eat(tt.star);\n  }\n\n  maybeParseExportDefaultSpecifier(node: N.Node): boolean {\n    if (this.isExportDefaultSpecifier()) {\n      // export defaultObj ...\n      this.expectPlugin(\"exportDefaultFrom\");\n      const specifier = this.startNode();\n      specifier.exported = this.parseIdentifier(true);\n      node.specifiers = [this.finishNode(specifier, \"ExportDefaultSpecifier\")];\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamespaceSpecifier(node: N.Node): boolean {\n    if (this.isContextual(tt._as)) {\n      if (!node.specifiers) node.specifiers = [];\n\n      const specifier = this.startNodeAt(this.state.lastTokStartLoc);\n\n      this.next();\n\n      specifier.exported = this.parseModuleExportName();\n      node.specifiers.push(\n        this.finishNode(specifier, \"ExportNamespaceSpecifier\"),\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportNamedSpecifiers(node: N.Node): boolean {\n    if (this.match(tt.braceL)) {\n      if (!node.specifiers) node.specifiers = [];\n      const isTypeExport = node.exportKind === \"type\";\n      node.specifiers.push(...this.parseExportSpecifiers(isTypeExport));\n\n      node.source = null;\n      node.declaration = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseExportDeclaration(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n  ): boolean {\n    if (this.shouldParseExportDeclaration()) {\n      node.specifiers = [];\n      node.source = null;\n      if (this.hasPlugin(\"importAssertions\")) {\n        node.assertions = [];\n      }\n      node.declaration = this.parseExportDeclaration(node);\n      return true;\n    }\n    return false;\n  }\n\n  isAsyncFunction(): boolean {\n    if (!this.isContextual(tt._async)) return false;\n    const next = this.nextTokenStart();\n    return (\n      !lineBreak.test(this.input.slice(this.state.pos, next)) &&\n      this.isUnparsedContextual(next, \"function\")\n    );\n  }\n\n  parseExportDefaultExpression(this: Parser): N.Expression | N.Declaration {\n    const expr = this.startNode();\n\n    if (this.match(tt._function)) {\n      this.next();\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration | ParseFunctionFlag.NullableId,\n      );\n    } else if (this.isAsyncFunction()) {\n      this.next(); // eat 'async'\n      this.next(); // eat 'function'\n      return this.parseFunction(\n        expr as Undone<N.FunctionDeclaration>,\n        ParseFunctionFlag.Declaration |\n          ParseFunctionFlag.NullableId |\n          ParseFunctionFlag.Async,\n      );\n    }\n\n    if (this.match(tt._class)) {\n      return this.parseClass(expr as Undone<N.ClassExpression>, true, true);\n    }\n\n    if (this.match(tt.at)) {\n      if (\n        this.hasPlugin(\"decorators\") &&\n        this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n      ) {\n        this.raise(Errors.DecoratorBeforeExport, { at: this.state.startLoc });\n      }\n      return this.parseClass(\n        this.maybeTakeDecorators(\n          this.parseDecorators(false),\n          this.startNode<N.ClassDeclaration>(),\n        ),\n        true,\n        true,\n      );\n    }\n\n    if (this.match(tt._const) || this.match(tt._var) || this.isLet()) {\n      throw this.raise(Errors.UnsupportedDefaultExport, {\n        at: this.state.startLoc,\n      });\n    }\n\n    const res = this.parseMaybeAssignAllowIn();\n    this.semicolon();\n    return res;\n  }\n\n  // https://tc39.es/ecma262/#prod-ExportDeclaration\n  parseExportDeclaration(\n    this: Parser,\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    node: Undone<N.ExportNamedDeclaration>,\n  ): N.Declaration | undefined | null {\n    if (this.match(tt._class)) {\n      const node = this.parseClass(\n        this.startNode<N.ClassDeclaration>(),\n        true,\n        false,\n      );\n      return node;\n    }\n    return this.parseStatementListItem() as N.Declaration;\n  }\n\n  isExportDefaultSpecifier(): boolean {\n    const { type } = this.state;\n    if (tokenIsIdentifier(type)) {\n      if ((type === tt._async && !this.state.containsEsc) || type === tt._let) {\n        return false;\n      }\n      if (\n        (type === tt._type || type === tt._interface) &&\n        !this.state.containsEsc\n      ) {\n        const { type: nextType } = this.lookahead();\n        // If we see any variable name other than `from` after `type` keyword,\n        // we consider it as flow/typescript type exports\n        // note that this approach may fail on some pedantic cases\n        // export type from = number\n        if (\n          (tokenIsIdentifier(nextType) && nextType !== tt._from) ||\n          nextType === tt.braceL\n        ) {\n          this.expectOnePlugin([\"flow\", \"typescript\"]);\n          return false;\n        }\n      }\n    } else if (!this.match(tt._default)) {\n      return false;\n    }\n\n    const next = this.nextTokenStart();\n    const hasFrom = this.isUnparsedContextual(next, \"from\");\n    if (\n      this.input.charCodeAt(next) === charCodes.comma ||\n      (tokenIsIdentifier(this.state.type) && hasFrom)\n    ) {\n      return true;\n    }\n    // lookahead again when `export default from` is seen\n    if (this.match(tt._default) && hasFrom) {\n      const nextAfterFrom = this.input.charCodeAt(\n        this.nextTokenStartSince(next + 4),\n      );\n      return (\n        nextAfterFrom === charCodes.quotationMark ||\n        nextAfterFrom === charCodes.apostrophe\n      );\n    }\n    return false;\n  }\n\n  parseExportFrom(\n    this: Parser,\n    node: Undone<N.ExportNamedDeclaration>,\n    expect?: boolean,\n  ): void {\n    if (this.eatContextual(tt._from)) {\n      node.source = this.parseImportSource();\n      this.checkExport(node);\n      const assertions = this.maybeParseImportAssertions();\n      if (assertions) {\n        node.assertions = assertions;\n        this.checkJSONModuleImport(node);\n      }\n    } else if (expect) {\n      this.unexpected();\n    }\n\n    this.semicolon();\n  }\n\n  shouldParseExportDeclaration(): boolean {\n    const { type } = this.state;\n    if (type === tt.at) {\n      this.expectOnePlugin([\"decorators\", \"decorators-legacy\"]);\n      if (this.hasPlugin(\"decorators\")) {\n        if (\n          this.getPluginOption(\"decorators\", \"decoratorsBeforeExport\") === true\n        ) {\n          this.raise(Errors.DecoratorBeforeExport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        return true;\n      }\n    }\n\n    return (\n      type === tt._var ||\n      type === tt._const ||\n      type === tt._function ||\n      type === tt._class ||\n      this.isLet() ||\n      this.isAsyncFunction()\n    );\n  }\n\n  checkExport(\n    node: Undone<N.ExportNamedDeclaration | N.ExportDefaultDeclaration>,\n    checkNames?: boolean,\n    isDefault?: boolean,\n    isFrom?: boolean,\n  ): void {\n    if (checkNames) {\n      // Check for duplicate exports\n      if (isDefault) {\n        // Default exports\n        this.checkDuplicateExports(node, \"default\");\n        if (this.hasPlugin(\"exportDefaultFrom\")) {\n          const declaration = (node as any as N.ExportDefaultDeclaration)\n            .declaration;\n          if (\n            declaration.type === \"Identifier\" &&\n            declaration.name === \"from\" &&\n            declaration.end - declaration.start === 4 && // does not contain escape\n            !declaration.extra?.parenthesized\n          ) {\n            this.raise(Errors.ExportDefaultFromAsIdentifier, {\n              at: declaration,\n            });\n          }\n        }\n        // @ts-expect-error node.specifiers may not exist\n      } else if (node.specifiers && node.specifiers.length) {\n        // Named exports\n        // @ts-expect-error node.specifiers may not exist\n        for (const specifier of node.specifiers) {\n          const { exported } = specifier;\n          const exportName =\n            exported.type === \"Identifier\" ? exported.name : exported.value;\n          this.checkDuplicateExports(specifier, exportName);\n          if (!isFrom && specifier.local) {\n            const { local } = specifier;\n            if (local.type !== \"Identifier\") {\n              this.raise(Errors.ExportBindingIsString, {\n                at: specifier,\n                localName: local.value,\n                exportName,\n              });\n            } else {\n              // check for keywords used as local names\n              this.checkReservedWord(local.name, local.loc.start, true, false);\n              // check if export is defined\n              this.scope.checkLocalExport(local);\n            }\n          }\n        }\n      } else if (node.declaration) {\n        // Exported declarations\n        if (\n          node.declaration.type === \"FunctionDeclaration\" ||\n          node.declaration.type === \"ClassDeclaration\"\n        ) {\n          const id = node.declaration.id;\n          if (!id) throw new Error(\"Assertion failure\");\n\n          this.checkDuplicateExports(node, id.name);\n        } else if (node.declaration.type === \"VariableDeclaration\") {\n          for (const declaration of node.declaration.declarations) {\n            this.checkDeclaration(declaration.id);\n          }\n        }\n      }\n    }\n  }\n\n  checkDeclaration(node: N.Pattern | N.ObjectProperty): void {\n    if (node.type === \"Identifier\") {\n      this.checkDuplicateExports(node, node.name);\n    } else if (node.type === \"ObjectPattern\") {\n      for (const prop of node.properties) {\n        this.checkDeclaration(prop);\n      }\n    } else if (node.type === \"ArrayPattern\") {\n      for (const elem of node.elements) {\n        if (elem) {\n          this.checkDeclaration(elem);\n        }\n      }\n    } else if (node.type === \"ObjectProperty\") {\n      // @ts-expect-error migrate to Babel types\n      this.checkDeclaration(node.value);\n    } else if (node.type === \"RestElement\") {\n      this.checkDeclaration(node.argument);\n    } else if (node.type === \"AssignmentPattern\") {\n      this.checkDeclaration(node.left);\n    }\n  }\n\n  checkDuplicateExports(\n    node: Undone<\n      | N.Identifier\n      | N.StringLiteral\n      | N.ExportNamedDeclaration\n      | N.ExportSpecifier\n      | N.ExportDefaultSpecifier\n    >,\n    exportName: string,\n  ): void {\n    if (this.exportedIdentifiers.has(exportName)) {\n      if (exportName === \"default\") {\n        this.raise(Errors.DuplicateDefaultExport, { at: node });\n      } else {\n        this.raise(Errors.DuplicateExport, { at: node, exportName });\n      }\n    }\n    this.exportedIdentifiers.add(exportName);\n  }\n\n  // Parses a comma-separated list of module exports.\n\n  parseExportSpecifiers(isInTypeExport: boolean): Array<N.ExportSpecifier> {\n    const nodes = [];\n    let first = true;\n\n    // export { x, y as z } [from '...']\n    this.expect(tt.braceL);\n\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      const isString = this.match(tt.string);\n      const node = this.startNode();\n      node.local = this.parseModuleExportName();\n      nodes.push(\n        this.parseExportSpecifier(\n          node,\n          isString,\n          isInTypeExport,\n          isMaybeTypeOnly,\n        ),\n      );\n    }\n\n    return nodes;\n  }\n\n  parseExportSpecifier(\n    node: any,\n    isString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript parser */\n    isInTypeExport: boolean,\n    isMaybeTypeOnly: boolean,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ExportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      node.exported = this.parseModuleExportName();\n    } else if (isString) {\n      node.exported = cloneStringLiteral(node.local);\n    } else if (!node.exported) {\n      node.exported = cloneIdentifier(node.local);\n    }\n    return this.finishNode<N.ExportSpecifier>(node, \"ExportSpecifier\");\n  }\n\n  // https://tc39.es/ecma262/#prod-ModuleExportName\n  parseModuleExportName(): N.StringLiteral | N.Identifier {\n    if (this.match(tt.string)) {\n      const result = this.parseStringLiteral(this.state.value);\n      const surrogate = result.value.match(loneSurrogate);\n      if (surrogate) {\n        this.raise(Errors.ModuleExportNameHasLoneSurrogate, {\n          at: result,\n          surrogateCharCode: surrogate[0].charCodeAt(0),\n        });\n      }\n      return result;\n    }\n    return this.parseIdentifier(true);\n  }\n\n  isJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ): boolean {\n    if (node.assertions != null) {\n      return node.assertions.some(({ key, value }) => {\n        return (\n          value.value === \"json\" &&\n          (key.type === \"Identifier\"\n            ? key.name === \"type\"\n            : key.value === \"type\")\n        );\n      });\n    }\n    return false;\n  }\n\n  checkImportReflection(node: Undone<N.ImportDeclaration>) {\n    if (node.module) {\n      if (\n        node.specifiers.length !== 1 ||\n        node.specifiers[0].type !== \"ImportDefaultSpecifier\"\n      ) {\n        this.raise(Errors.ImportReflectionNotBinding, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n      if (node.assertions?.length > 0) {\n        this.raise(Errors.ImportReflectionHasAssertion, {\n          at: node.specifiers[0].loc.start,\n        });\n      }\n    }\n  }\n\n  checkJSONModuleImport(\n    node: Undone<\n      N.ExportAllDeclaration | N.ExportNamedDeclaration | N.ImportDeclaration\n    >,\n  ) {\n    // @ts-expect-error Fixme: node.type must be undefined because they are undone\n    if (this.isJSONModuleImport(node) && node.type !== \"ExportAllDeclaration\") {\n      // @ts-expect-error specifiers may not index node\n      const { specifiers } = node;\n      if (specifiers != null) {\n        // @ts-expect-error refine specifier types\n        const nonDefaultNamedSpecifier = specifiers.find(specifier => {\n          let imported;\n          if (specifier.type === \"ExportSpecifier\") {\n            imported = specifier.local;\n          } else if (specifier.type === \"ImportSpecifier\") {\n            imported = specifier.imported;\n          }\n          if (imported !== undefined) {\n            return imported.type === \"Identifier\"\n              ? imported.name !== \"default\"\n              : imported.value !== \"default\";\n          }\n        });\n        if (nonDefaultNamedSpecifier !== undefined) {\n          this.raise(Errors.ImportJSONBindingNotDefault, {\n            at: nonDefaultNamedSpecifier.loc.start,\n          });\n        }\n      }\n    }\n  }\n\n  parseMaybeImportReflection(node: Undone<N.ImportDeclaration>) {\n    let isImportReflection = false;\n    if (this.isContextual(tt._module)) {\n      const lookahead = this.lookahead();\n      const nextType = lookahead.type;\n      if (tokenIsIdentifier(nextType)) {\n        if (nextType !== tt._from) {\n          // import module x\n          isImportReflection = true;\n        } else {\n          const nextNextTokenFirstChar = this.input.charCodeAt(\n            this.nextTokenStartSince(lookahead.end),\n          );\n          if (nextNextTokenFirstChar === charCodes.lowercaseF) {\n            // import module from from ...\n            isImportReflection = true;\n          }\n        }\n      } else if (nextType !== tt.comma) {\n        // import module { x } ...\n        // import module \"foo\"\n        // They are invalid, we will continue parsing and throw\n        // a recoverable error later\n        isImportReflection = true;\n      }\n    }\n    if (isImportReflection) {\n      this.expectPlugin(\"importReflection\");\n      this.next(); // eat tt._module;\n      node.module = true;\n    } else if (this.hasPlugin(\"importReflection\")) {\n      node.module = false;\n    }\n  }\n\n  // Parses import declaration.\n  // https://tc39.es/ecma262/#prod-ImportDeclaration\n\n  parseImport(this: Parser, node: Undone<N.ImportDeclaration>): N.AnyImport {\n    // import '...'\n    node.specifiers = [];\n    if (!this.match(tt.string)) {\n      this.parseMaybeImportReflection(node);\n      // check if we have a default import like\n      // import React from \"react\";\n      const hasDefault = this.maybeParseDefaultImportSpecifier(node);\n      /* we are checking if we do not have a default import, then it is obvious that we need named imports\n       * import { get } from \"axios\";\n       * but if we do have a default import\n       * we need to check if we have a comma after that and\n       * that is where this `|| this.eat` condition comes into play\n       */\n      const parseNext = !hasDefault || this.eat(tt.comma);\n      // if we do have to parse the next set of specifiers, we first check for star imports\n      // import React, * from \"react\";\n      const hasStar = parseNext && this.maybeParseStarImportSpecifier(node);\n      // now we check if we need to parse the next imports\n      // but only if they are not importing * (everything)\n      if (parseNext && !hasStar) this.parseNamedImportSpecifiers(node);\n      this.expectContextual(tt._from);\n    }\n    node.source = this.parseImportSource();\n    // https://github.com/tc39/proposal-import-assertions\n    // parse module import assertions if the next token is `assert` or ignore\n    // and finish the ImportDeclaration node.\n    const assertions = this.maybeParseImportAssertions();\n    if (assertions) {\n      node.assertions = assertions;\n    } else if (!process.env.BABEL_8_BREAKING) {\n      const attributes = this.maybeParseModuleAttributes();\n      if (attributes) {\n        // @ts-expect-error attributes have been deprecated\n        node.attributes = attributes;\n      }\n    }\n    this.checkImportReflection(node);\n    this.checkJSONModuleImport(node);\n\n    this.semicolon();\n    return this.finishNode(node, \"ImportDeclaration\");\n  }\n\n  parseImportSource(this: Parser): N.StringLiteral {\n    if (!this.match(tt.string)) this.unexpected();\n    return this.parseExprAtom() as N.StringLiteral;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  shouldParseDefaultImport(node: Undone<N.ImportDeclaration>): boolean {\n    return tokenIsIdentifier(this.state.type);\n  }\n\n  parseImportSpecifierLocal<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(\n    node: Undone<N.ImportDeclaration>,\n    specifier: Undone<T>,\n    type: T[\"type\"],\n  ): void {\n    specifier.local = this.parseIdentifier();\n    node.specifiers.push(this.finishImportSpecifier(specifier, type));\n  }\n\n  finishImportSpecifier<\n    T extends\n      | N.ImportSpecifier\n      | N.ImportDefaultSpecifier\n      | N.ImportNamespaceSpecifier,\n  >(specifier: Undone<T>, type: T[\"type\"], bindingType = BIND_LEXICAL) {\n    this.checkLVal(specifier.local, {\n      in: { type },\n      binding: bindingType,\n    });\n    return this.finishNode(specifier, type);\n  }\n\n  /**\n   * parse assert entries\n   *\n   * @see {@link https://tc39.es/proposal-import-assertions/#prod-AssertEntries AssertEntries}\n   */\n  parseAssertEntries(): N.ImportAttribute[] {\n    const attrs = [];\n    const attrNames = new Set();\n\n    do {\n      if (this.match(tt.braceR)) {\n        break;\n      }\n\n      const node = this.startNode<N.ImportAttribute>();\n\n      // parse AssertionKey : IdentifierName, StringLiteral\n      const keyName = this.state.value;\n      // check if we already have an entry for an attribute\n      // if a duplicate entry is found, throw an error\n      // for now this logic will come into play only when someone declares `type` twice\n      if (attrNames.has(keyName)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: this.state.startLoc,\n          key: keyName,\n        });\n      }\n      attrNames.add(keyName);\n      if (this.match(tt.string)) {\n        node.key = this.parseStringLiteral(keyName);\n      } else {\n        node.key = this.parseIdentifier(true);\n      }\n      this.expect(tt.colon);\n\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      attrs.push(this.finishNode(node, \"ImportAttribute\"));\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  /**\n   * parse module attributes\n   * @deprecated It will be removed in Babel 8\n   */\n  maybeParseModuleAttributes() {\n    if (this.match(tt._with) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"moduleAttributes\");\n      this.next();\n    } else {\n      if (this.hasPlugin(\"moduleAttributes\")) return [];\n      return null;\n    }\n    const attrs = [];\n    const attributes = new Set();\n    do {\n      const node = this.startNode();\n      node.key = this.parseIdentifier(true);\n\n      if (node.key.name !== \"type\") {\n        this.raise(Errors.ModuleAttributeDifferentFromType, {\n          at: node.key,\n        });\n      }\n\n      if (attributes.has(node.key.name)) {\n        this.raise(Errors.ModuleAttributesWithDuplicateKeys, {\n          at: node.key,\n          key: node.key.name,\n        });\n      }\n      attributes.add(node.key.name);\n      this.expect(tt.colon);\n      if (!this.match(tt.string)) {\n        throw this.raise(Errors.ModuleAttributeInvalidValue, {\n          at: this.state.startLoc,\n        });\n      }\n      node.value = this.parseStringLiteral(this.state.value);\n      this.finishNode(node, \"ImportAttribute\");\n      attrs.push(node);\n    } while (this.eat(tt.comma));\n\n    return attrs;\n  }\n\n  maybeParseImportAssertions() {\n    // [no LineTerminator here] AssertClause\n    if (this.isContextual(tt._assert) && !this.hasPrecedingLineBreak()) {\n      this.expectPlugin(\"importAssertions\");\n      this.next(); // eat `assert`\n    } else {\n      if (this.hasPlugin(\"importAssertions\")) return [];\n      return null;\n    }\n    // https://tc39.es/proposal-import-assertions/#prod-AssertClause\n    this.eat(tt.braceL);\n    const attrs = this.parseAssertEntries();\n    this.eat(tt.braceR);\n\n    return attrs;\n  }\n\n  maybeParseDefaultImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.shouldParseDefaultImport(node)) {\n      // import defaultObj, { x, y as z } from '...'\n      this.parseImportSpecifierLocal(\n        node,\n        this.startNode<N.ImportDefaultSpecifier>(),\n        \"ImportDefaultSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  maybeParseStarImportSpecifier(node: Undone<N.ImportDeclaration>): boolean {\n    if (this.match(tt.star)) {\n      const specifier = this.startNode<N.ImportNamespaceSpecifier>();\n      this.next();\n      this.expectContextual(tt._as);\n\n      this.parseImportSpecifierLocal(\n        node,\n        specifier,\n        \"ImportNamespaceSpecifier\",\n      );\n      return true;\n    }\n    return false;\n  }\n\n  parseNamedImportSpecifiers(node: Undone<N.ImportDeclaration>) {\n    let first = true;\n    this.expect(tt.braceL);\n    while (!this.eat(tt.braceR)) {\n      if (first) {\n        first = false;\n      } else {\n        // Detect an attempt to deep destructure\n        if (this.eat(tt.colon)) {\n          throw this.raise(Errors.DestructureNamedImport, {\n            at: this.state.startLoc,\n          });\n        }\n\n        this.expect(tt.comma);\n        if (this.eat(tt.braceR)) break;\n      }\n\n      const specifier = this.startNode<N.ImportSpecifier>();\n      const importedIsString = this.match(tt.string);\n      const isMaybeTypeOnly = this.isContextual(tt._type);\n      specifier.imported = this.parseModuleExportName();\n      const importSpecifier = this.parseImportSpecifier(\n        specifier,\n        importedIsString,\n        node.importKind === \"type\" || node.importKind === \"typeof\",\n        isMaybeTypeOnly,\n        undefined,\n      );\n      node.specifiers.push(importSpecifier);\n    }\n  }\n\n  // https://tc39.es/ecma262/#prod-ImportSpecifier\n  parseImportSpecifier(\n    specifier: Undone<N.ImportSpecifier>,\n    importedIsString: boolean,\n    /* eslint-disable @typescript-eslint/no-unused-vars -- used in TypeScript and Flow parser */\n    isInTypeOnlyImport: boolean,\n    isMaybeTypeOnly: boolean,\n    bindingType: BindingTypes | undefined,\n    /* eslint-enable @typescript-eslint/no-unused-vars */\n  ): N.ImportSpecifier {\n    if (this.eatContextual(tt._as)) {\n      specifier.local = this.parseIdentifier();\n    } else {\n      const { imported } = specifier;\n      if (importedIsString) {\n        throw this.raise(Errors.ImportBindingIsString, {\n          at: specifier,\n          importName: (imported as N.StringLiteral).value,\n        });\n      }\n      this.checkReservedWord(\n        (imported as N.Identifier).name,\n        specifier.loc.start,\n        true,\n        true,\n      );\n      if (!specifier.local) {\n        specifier.local = cloneIdentifier(imported);\n      }\n    }\n    return this.finishImportSpecifier(\n      specifier,\n      \"ImportSpecifier\",\n      bindingType,\n    );\n  }\n\n  // This is used in flow and typescript plugin\n  // Determine whether a parameter is a this param\n  isThisParam(\n    param: N.Pattern | N.Identifier | N.TSParameterProperty,\n  ): boolean {\n    return param.type === \"Identifier\" && param.name === \"this\";\n  }\n}\n"],"mappings":"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"}